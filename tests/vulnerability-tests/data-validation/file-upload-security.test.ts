import { describe, test, expect } from '@jest/globals';
import * as fs from 'fs';
import * as path from 'path';

describe('File Upload Security Vulnerabilities', () => {
  test('File size validation - detects unrestricted uploads', async () => {
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    
    // Vulnerable implementation (what we're testing for)
    const vulnerableValidateFileSize = (fileSize: number) => {
      // BUG: No file size validation
      return true;
    };

    // Secure implementation (what it should be)
    const secureValidateFileSize = (fileSize: number) => {
      return fileSize <= MAX_FILE_SIZE;
    };

    // Test various file sizes
    const fileSizes = [
      50 * 1024 * 1024,    // 50MB
      100 * 1024 * 1024,   // 100MB
      500 * 1024 * 1024,   // 500MB
      1024 * 1024 * 1024   // 1GB
    ];

    // Check that vulnerable implementation fails to validate
    for (const size of fileSizes) {
      const vulnerableResult = vulnerableValidateFileSize(size);
      const secureResult = secureValidateFileSize(size);
      
      // The vulnerable function always returns true (accepts everything)
      expect(vulnerableResult).toBe(true);
      
      // The secure function should reject files over 10MB
      if (size > MAX_FILE_SIZE) {
        expect(secureResult).toBe(false);
      }
    }
    
    // Test passes by demonstrating the vulnerability exists
    expect(vulnerableValidateFileSize(1024 * 1024 * 1024)).toBe(true);
  });

  test('Double extension bypass - detects filename validation issues', async () => {
    const dangerousFilenames = [
      'malware.xlsx.exe',
      'script.csv.js',
      'payload.xls.php',
      'virus.xlsx.bat',
      'exploit.csv.jsp',
      'shell.xlsx.aspx'
    ];

    // Vulnerable implementation
    const vulnerableIsValidFileName = (filename: string) => {
      // BUG: Only checks last extension
      const ext = path.extname(filename).toLowerCase();
      const allowed = ['.xlsx', '.xls', '.csv'];
      return allowed.includes(ext);
    };

    // Secure implementation
    const secureIsValidFileName = (filename: string) => {
      // Check for multiple extensions
      const parts = filename.split('.');
      if (parts.length > 2) {
        // Check all extensions
        const dangerousExtensions = ['.exe', '.js', '.php', '.bat', '.jsp', '.aspx'];
        for (let i = 1; i < parts.length; i++) {
          if (dangerousExtensions.includes('.' + parts[i].toLowerCase())) {
            return false;
          }
        }
      }
      const ext = path.extname(filename).toLowerCase();
      const allowed = ['.xlsx', '.xls', '.csv'];
      return allowed.includes(ext);
    };

    for (const filename of dangerousFilenames) {
      const vulnerableResult = vulnerableIsValidFileName(filename);
      const secureResult = secureIsValidFileName(filename);
      
      // Since the vulnerable function checks the LAST extension (.exe, .js, etc),
      // it actually correctly rejects these files (though for the wrong reason)
      expect(vulnerableResult).toBe(false);
      // Secure function correctly rejects them
      expect(secureResult).toBe(false);
    }
  });

  test('MIME type mismatch detection - validates content checking', async () => {
    const fileTests = [
      {
        fullName: 'spreadsheet.xlsx',
        declaredType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        actualContent: '#!/bin/bash\nrm -rf /',
        shouldBeValid: false
      },
      {
        fullName: 'data.csv',
        declaredType: 'text/csv',
        actualContent: '<?php system($_GET["cmd"]); ?>',
        shouldBeValid: false
      },
      {
        fullName: 'report.xlsx',
        declaredType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        actualContent: Buffer.from('4D5A90', 'hex'), // PE executable header
        shouldBeValid: false
      }
    ];

    // Vulnerable implementation
    const vulnerableValidateFile = (name: string, mimeType: string, content: any) => {
      // BUG: Doesn't check actual file content
      const validTypes = [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv'
      ];
      return validTypes.includes(mimeType);
    };

    // Secure implementation
    const secureValidateFile = (name: string, mimeType: string, content: any) => {
      const validTypes = [
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-excel',
        'text/csv'
      ];
      if (!validTypes.includes(mimeType)) return false;
      
      // Check content for suspicious patterns
      const contentStr = content.toString();
      const suspiciousPatterns = [
        '#!/bin/',
        '<?php',
        '<script',
        'system(',
        'exec('
      ];
      
      for (const pattern of suspiciousPatterns) {
        if (contentStr.includes(pattern)) return false;
      }
      
      // Check for PE header
      if (Buffer.isBuffer(content)) {
        const peHeader = Buffer.from('4D5A', 'hex');
        if (content.slice(0, 2).equals(peHeader)) return false;
      }
      
      return true;
    };

    for (const test of fileTests) {
      const vulnerableResult = vulnerableValidateFile(test.fullName, test.declaredType, test.actualContent);
      const secureResult = secureValidateFile(test.fullName, test.declaredType, test.actualContent);
      
      // Vulnerable function fails to detect malicious content
      expect(vulnerableResult).toBe(true);
      // Secure function correctly identifies it
      expect(secureResult).toBe(test.shouldBeValid);
    }
  });

  test('Zip bomb protection - validates compression ratio checks', async () => {
    // Vulnerable implementation
    const vulnerableCheckZipBomb = (compressedSize: number, uncompressedSize: number) => {
      // BUG: No zip bomb detection
      return true;
    };

    // Secure implementation
    const secureCheckZipBomb = (compressedSize: number, uncompressedSize: number) => {
      const ratio = uncompressedSize / compressedSize;
      const MAX_COMPRESSION_RATIO = 100;
      const MAX_UNCOMPRESSED_SIZE = 100 * 1024 * 1024; // 100MB
      
      if (ratio > MAX_COMPRESSION_RATIO) return false;
      if (uncompressedSize > MAX_UNCOMPRESSED_SIZE) return false;
      return true;
    };

    // Zip bomb characteristics
    const zipBombs = [
      { compressed: 1024, uncompressed: 1024 * 1024 * 1024 }, // 1KB -> 1GB
      { compressed: 42 * 1024, uncompressed: 4.5 * 1024 * 1024 * 1024 }, // 42KB -> 4.5GB
      { compressed: 10 * 1024, uncompressed: 281 * 1024 * 1024 * 1024 } // 10KB -> 281GB
    ];

    for (const bomb of zipBombs) {
      const ratio = bomb.uncompressed / bomb.compressed;
      const vulnerableResult = vulnerableCheckZipBomb(bomb.compressed, bomb.uncompressed);
      const secureResult = secureCheckZipBomb(bomb.compressed, bomb.uncompressed);
      
      // Vulnerable function fails to detect zip bombs
      expect(vulnerableResult).toBe(true);
      
      // Secure function should detect suspicious compression ratios (>100:1)
      if (ratio > 100) {
        expect(secureResult).toBe(false);
      }
    }
  });

  test('Filename sanitization - validates proper filename cleaning', async () => {
    const maliciousFilenames = [
      '../../../etc/passwd.xlsx',
      '..\\..\\windows\\win.ini.csv',
      'file\x00.xlsx', // Null byte
      'file%00.csv',
      'file%2e%2e%2f.xlsx',
      'CON.xlsx', // Windows reserved name
      'PRN.csv',
      'AUX.xls',
      '.htaccess.xlsx',
      'web.config.csv'
    ];

    // Vulnerable implementation
    const vulnerableSanitizeFilename = (filename: string) => {
      // BUG: Insufficient sanitization
      return filename.replace(/\.\./g, '');
    };

    // Secure implementation
    const secureSanitizeFilename = (filename: string) => {
      // Remove path traversal attempts
      let sanitized = filename.replace(/\.\./g, '');
      sanitized = sanitized.replace(/[\\/:*?"<>|]/g, '_');
      
      // Remove null bytes
      sanitized = sanitized.replace(/\x00/g, '');
      sanitized = sanitized.replace(/%00/g, '');
      
      // Decode URL encoding
      try {
        sanitized = decodeURIComponent(sanitized);
      } catch (e) {
        // If decoding fails, keep original
      }
      
      // Remove any remaining path traversal
      sanitized = sanitized.replace(/\.\./g, '');
      
      // Handle Windows reserved names
      const reservedNames = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(\.|$)/i;
      if (reservedNames.test(sanitized)) {
        sanitized = '_' + sanitized;
      }
      
      // Remove leading dots
      sanitized = sanitized.replace(/^\.+/, '');
      
      return sanitized;
    };

    for (const filename of maliciousFilenames) {
      const vulnerableResult = vulnerableSanitizeFilename(filename);
      const secureResult = secureSanitizeFilename(filename);
      
      // Test that vulnerable implementation leaves some issues
      // The vulnerable function only removes '..' but doesn't handle other issues
      const hasIssues = 
        vulnerableResult.includes('\x00') ||
        vulnerableResult.includes('%00') ||
        /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])\./i.test(vulnerableResult) ||
        /^\./.test(vulnerableResult) ||
        vulnerableResult.includes('\\') ||
        vulnerableResult.includes('/');
      
      // At least one of our test cases should have issues after vulnerable sanitization
      if (filename.includes('\x00') || filename.includes('%00') || 
          /^(CON|PRN|AUX|NUL)/i.test(filename) || filename.startsWith('.') ||
          filename.includes('\\') || filename.includes('/')) {
        expect(hasIssues).toBe(true);
      }
      
      // Secure implementation should clean all issues
      expect(secureResult).not.toContain('..');
      expect(secureResult).not.toContain('\x00');
      expect(secureResult).not.toContain('%00');
      expect(secureResult).not.toMatch(/^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])\./i);
      expect(secureResult).not.toMatch(/^\./);
    }
  });

  test('Concurrent file upload race condition - validates unique filename generation', async () => {
    let uploadCounter = 0;
    const uploadDir = '/tmp/uploads';
    
    // Vulnerable implementation
    const vulnerableHandleFileUpload = async (filename: string) => {
      // BUG: Race condition in filename generation
      const timestamp = Date.now();
      const uploadPath = `${uploadDir}/${timestamp}_${filename}`;
      
      // Simulate file processing delay
      await new Promise(resolve => setTimeout(resolve, 10));
      
      uploadCounter++;
      return uploadPath;
    };

    // Secure implementation
    let secureCounter = 0;
    const secureHandleFileUpload = async (filename: string) => {
      // Use atomic counter or UUID
      const uniqueId = `${Date.now()}_${process.hrtime()[1]}_${++secureCounter}`;
      const uploadPath = `${uploadDir}/${uniqueId}_${filename}`;
      
      // Simulate file processing delay
      await new Promise(resolve => setTimeout(resolve, 10));
      
      return uploadPath;
    };

    // Test vulnerable implementation
    const vulnerableUploads = Array(5).fill('data.xlsx').map(filename => 
      vulnerableHandleFileUpload(filename)
    );

    const vulnerablePaths = await Promise.all(vulnerableUploads);
    const vulnerableUniquePaths = new Set(vulnerablePaths);
    
    // Vulnerable implementation might have duplicates
    // We can't guarantee it will fail, so we just check it runs
    expect(vulnerablePaths.length).toBe(5);
    
    // Test secure implementation
    const secureUploads = Array(5).fill('data.xlsx').map(filename => 
      secureHandleFileUpload(filename)
    );

    const securePaths = await Promise.all(secureUploads);
    const secureUniquePaths = new Set(securePaths);
    
    // Secure implementation should always have unique paths
    expect(secureUniquePaths.size).toBe(5);
  });

  test('Excel macro detection - validates macro identification', async () => {
    // Vulnerable implementation
    const vulnerableDetectMacros = (fileContent: Buffer) => {
      // BUG: No macro detection
      return false;
    };

    // Secure implementation
    const secureDetectMacros = (fileContent: Buffer) => {
      const contentStr = fileContent.toString('hex');
      const contentUtf8 = fileContent.toString('utf8');
      
      // Check for OLE file header
      if (contentStr.startsWith('d0cf11e0a1b11ae1')) return true;
      
      // Check for XLSM structure
      if (contentUtf8.includes('xl/vbaProject.bin')) return true;
      
      // Check for VBA code
      if (contentUtf8.includes('Attribute VB_Name')) return true;
      
      return false;
    };

    // Signatures of files with macros
    const macroSignatures = [
      Buffer.from('d0cf11e0a1b11ae1', 'hex'), // OLE file header
      Buffer.from('504b0304' + 'xl/vbaProject.bin', 'utf8'), // XLSM structure
      Buffer.from('Attribute VB_Name', 'utf8') // VBA code
    ];

    for (const signature of macroSignatures) {
      const vulnerableResult = vulnerableDetectMacros(signature);
      const secureResult = secureDetectMacros(signature);
      
      // Vulnerable function fails to detect macros
      expect(vulnerableResult).toBe(false);
      // Secure function correctly identifies them
      expect(secureResult).toBe(true);
    }
  });

  test('Polyglot file detection - validates multi-format file identification', async () => {
    // Vulnerable implementation
    const vulnerableDetectPolyglot = (content: Buffer) => {
      // BUG: No polyglot detection
      return false;
    };

    // Secure implementation
    const secureDetectPolyglot = (content: Buffer) => {
      const knownHeaders = [
        { fullName: 'JPEG', header: Buffer.from('FFD8FF', 'hex') },
        { fullName: 'PNG', header: Buffer.from('89504E47', 'hex') },
        { fullName: 'ZIP', header: Buffer.from('504B0304', 'hex') },
        { fullName: 'PDF', header: Buffer.from('255044462D', 'hex') },
        { fullName: 'EXE', header: Buffer.from('4D5A', 'hex') }
      ];
      
      let foundHeaders = 0;
      for (const { header } of knownHeaders) {
        if (content.indexOf(header) !== -1) {
          foundHeaders++;
        }
      }
      
      // If multiple format headers found, it's likely a polyglot
      return foundHeaders > 1;
    };

    // Create polyglot file (valid as both JPEG and ZIP)
    const jpegHeader = Buffer.from('FFD8FFE0', 'hex');
    const zipHeader = Buffer.from('504B0304', 'hex');
    const polyglot = Buffer.concat([jpegHeader, Buffer.alloc(100), zipHeader]);

    const vulnerableResult = vulnerableDetectPolyglot(polyglot);
    const secureResult = secureDetectPolyglot(polyglot);
    
    // Vulnerable function fails to detect polyglot
    expect(vulnerableResult).toBe(false);
    // Secure function correctly identifies it
    expect(secureResult).toBe(true);
  });

  test('Resource exhaustion through nested archives - validates depth limits', async () => {
    // Vulnerable implementation
    const vulnerableValidateArchiveDepth = (file: any, depth: number = 0): boolean => {
      // BUG: No depth checking for nested archives
      return true;
    };

    // Secure implementation
    const secureValidateArchiveDepth = (file: any, depth: number = 0, maxDepth: number = 3): boolean => {
      if (depth > maxDepth) return false;
      
      if (file.contains) {
        return secureValidateArchiveDepth(file.contains, depth + 1, maxDepth);
      }
      
      return true;
    };

    // Simulate deeply nested archive structure
    const nestedStructure = {
      fullName: 'level1.zip',
      contains: {
        fullName: 'level2.zip',
        contains: {
          fullName: 'level3.zip',
          contains: {
            fullName: 'level4.zip',
            contains: {
              fullName: 'level5.xlsx'
            }
          }
        }
      }
    };

    const vulnerableResult = vulnerableValidateArchiveDepth(nestedStructure, 0);
    const secureResult = secureValidateArchiveDepth(nestedStructure, 0);
    
    // Vulnerable function doesn't check depth
    expect(vulnerableResult).toBe(true);
    // Secure function limits nesting depth
    expect(secureResult).toBe(false);
  });

  test('Symbolic link in archive - validates symlink handling', async () => {
    // Vulnerable implementation
    const vulnerableExtractArchive = (archivePath: string, extractTo: string) => {
      // BUG: Follows symbolic links during extraction
      const files = [
        { fullName: 'data.xlsx', type: 'file' },
        { fullName: 'link', type: 'symlink', target: '/etc/passwd' }
      ];
      
      return files;
    };

    // Secure implementation
    const secureExtractArchive = (archivePath: string, extractTo: string) => {
      const files = [
        { fullName: 'data.xlsx', type: 'file' },
        { fullName: 'link', type: 'symlink', target: '/etc/passwd' }
      ];
      
      // Filter out symbolic links
      return files.filter(f => f.type !== 'symlink');
    };

    const vulnerableExtracted = vulnerableExtractArchive('upload.zip', '/tmp/extract');
    const secureExtracted = secureExtractArchive('upload.zip', '/tmp/extract');
    
    const vulnerableHasSymlink = vulnerableExtracted.some(f => f.type === 'symlink');
    const secureHasSymlink = secureExtracted.some(f => f.type === 'symlink');
    
    // Vulnerable function includes symlinks
    expect(vulnerableHasSymlink).toBe(true);
    // Secure function filters them out
    expect(secureHasSymlink).toBe(false);
  });
});