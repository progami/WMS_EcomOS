import { test, expect, Page } from '@playwright/test';

test.describe('Race Condition UI Tests', () => {
  test.describe.configure({ mode: 'parallel' });

  test('SHOULD FAIL: Concurrent invoice number generation creates duplicates', async ({ browser }) => {
    // Create multiple browser contexts to simulate different users
    const contexts = await Promise.all([
      browser.newContext(),
      browser.newContext(),
      browser.newContext()
    ]);

    const pages = await Promise.all(
      contexts.map(ctx => ctx.newPage())
    );

    // Login all users
    await Promise.all(pages.map(async (page, index) => {
      await page.goto('/auth/login');
      await page.fill('input[name="email"]', `admin${index}@warehouse.com`);
      await page.fill('input[name="password"]', 'password123');
      await page.click('button[type="submit"]');
      await page.waitForURL('/dashboard');
    }));

    // Navigate all to invoice creation
    await Promise.all(pages.map(page => 
      page.goto('/finance/invoices/create')
    ));

    // Fill invoice forms identically
    await Promise.all(pages.map(async page => {
      await page.selectOption('select[name="customer"]', { index: 1 });
      await page.fill('input[name="amount"]', '1000');
      await page.fill('textarea[name="description"]', 'Test invoice');
    }));

    // Submit all invoices simultaneously
    const submitPromises = pages.map(page => 
      page.click('button:has-text("Create Invoice")')
    );

    await Promise.all(submitPromises);

    // Wait for all to complete
    await Promise.all(pages.map(page => 
      page.waitForURL('/finance/invoices/**')
    ));

    // Collect invoice numbers
    const invoiceNumbers = await Promise.all(pages.map(async page => {
      const invoiceNumber = await page.locator('.invoice-number').textContent();
      return invoiceNumber?.trim();
    }));

    // Check for duplicates
    const uniqueNumbers = new Set(invoiceNumbers);
    
    // This should fail - all invoice numbers should be unique
    expect(uniqueNumbers.size).toBe(invoiceNumbers.length);

    // Cleanup
    await Promise.all(contexts.map(ctx => ctx.close()));
  });

  test('SHOULD FAIL: Double-click purchase creates duplicate orders', async ({ page }) => {
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'customer@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    await page.goto('/orders/create');

    // Fill order form
    await page.fill('input[name="product"]', 'TEST-PRODUCT-001');
    await page.fill('input[name="quantity"]', '10');
    await page.fill('input[name="shipping"]', 'express');

    // Set up request interceptor
    let requestCount = 0;
    page.on('request', request => {
      if (request.url().includes('/api/orders/create')) {
        requestCount++;
      }
    });

    // Double-click submit button rapidly
    const submitButton = page.locator('button:has-text("Place Order")');
    await submitButton.dblclick();

    // Wait for navigation
    await page.waitForURL('/orders/confirmation/**', { timeout: 10000 });

    // Check if multiple requests were sent
    expect(requestCount).toBe(1); // Should only send one request despite double-click

    // Check order count via API
    const orders = await page.request.get('/api/orders/recent');
    const orderData = await orders.json();
    
    // Should not create duplicate orders
    const recentOrders = orderData.filter((o: any) => 
      o.product === 'TEST-PRODUCT-001' && 
      new Date(o.createdAt).getTime() > Date.now() - 60000
    );
    
    expect(recentOrders.length).toBe(1);
  });

  test('SHOULD FAIL: Rapid form resubmission bypasses validation', async ({ page }) => {
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'staff@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    await page.goto('/operations/adjust');

    // Fill adjustment form with invalid data
    await page.fill('input[name="sku"]', 'INVALID-SKU-999');
    await page.fill('input[name="adjustment"]', '999999'); // Unrealistic adjustment

    // Rapidly click submit multiple times
    const submitButton = page.locator('button[type="submit"]');
    
    // Click 5 times rapidly
    await Promise.all([
      submitButton.click(),
      submitButton.click(),
      submitButton.click(),
      submitButton.click(),
      submitButton.click()
    ]);

    // Check if any request succeeded
    await page.waitForTimeout(2000);
    
    const successMessage = await page.locator('.success-message').count();
    const errorMessage = await page.locator('.error-message').count();

    // All should fail - invalid SKU should be caught
    expect(successMessage).toBe(0);
    expect(errorMessage).toBeGreaterThan(0);
  });

  test('SHOULD FAIL: Browser back button after form submission duplicates action', async ({ page }) => {
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'admin@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // Create a new product
    await page.goto('/config/products/create');
    
    const uniqueSku = `TEST-SKU-${Date.now()}`;
    await page.fill('input[name="sku"]', uniqueSku);
    await page.fill('input[name="name"]', 'Test Product');
    await page.fill('input[name="barcode"]', `BAR${Date.now()}`);
    
    await page.click('button:has-text("Create Product")');
    await page.waitForURL('/config/products/**');

    // Go back to form
    await page.goBack();

    // Try to submit again
    await page.click('button:has-text("Create Product")');

    // Check for duplicate error
    const errorMessage = await page.locator('.error-message').textContent();
    
    // This should fail - duplicate SKU should be prevented
    expect(errorMessage).toContain('already exists');
  });

  test('SHOULD FAIL: Parallel batch operations on same inventory', async ({ browser }) => {
    const context1 = await browser.newContext();
    const context2 = await browser.newContext();
    
    const page1 = await context1.newPage();
    const page2 = await context2.newPage();

    // Login both pages
    for (const page of [page1, page2]) {
      await page.goto('/auth/login');
      await page.fill('input[name="email"]', 'admin@warehouse.com');
      await page.fill('input[name="password"]', 'password123');
      await page.click('button[type="submit"]');
    }

    // Both navigate to batch operations
    await page1.goto('/operations/batch/split');
    await page2.goto('/operations/batch/merge');

    // Page 1: Try to split a batch
    await page1.selectOption('select[name="batch"]', 'BATCH-001');
    await page1.fill('input[name="splitQuantity"]', '50');

    // Page 2: Try to merge the same batch
    await page2.selectOption('select[name="sourceBatch"]', 'BATCH-001');
    await page2.selectOption('select[name="targetBatch"]', 'BATCH-002');

    // Submit both operations simultaneously
    const [result1, result2] = await Promise.all([
      page1.click('button:has-text("Split Batch")').catch(() => 'error'),
      page2.click('button:has-text("Merge Batches")').catch(() => 'error')
    ]);

    // Check final batch state
    await page1.goto('/operations/inventory/batches');
    await page1.waitForLoadState('networkidle');

    const batch001 = await page1.locator('tr:has-text("BATCH-001")').first();
    const quantity = await batch001.locator('td.quantity').textContent();

    // Quantity should be consistent - not corrupted by concurrent operations
    expect(parseInt(quantity || '0')).toBeGreaterThanOrEqual(0);

    await context1.close();
    await context2.close();
  });

  test('SHOULD FAIL: Session fixation through shared links', async ({ page, context }) => {
    // Login as admin
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'admin@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // Navigate to reports
    await page.goto('/reports/inventory');

    // Get share link with session
    await page.click('button:has-text("Share Report")');
    const shareUrl = await page.locator('input.share-url').inputValue();

    // Open link in incognito context (different user)
    const incognitoContext = await context.browser()?.newContext();
    const incognitoPage = await incognitoContext!.newPage();
    
    await incognitoPage.goto(shareUrl);

    // Check if admin access is available
    const hasAdminMenu = await incognitoPage.locator('nav:has-text("Admin")').count();

    // This should fail - shared links shouldn't carry session
    expect(hasAdminMenu).toBe(0);

    await incognitoContext!.close();
  });
});