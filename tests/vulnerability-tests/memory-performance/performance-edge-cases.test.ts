import { describe, test, expect } from '@jest/globals';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

describe('Memory & Performance Edge Cases', () => {
  test('SHOULD FAIL: Large dataset export without pagination', async () => {
    // Simulate exporting large dataset
    const exportAllInventory = async () => {
      // BUG: Loads entire dataset into memory
      const allData = await prisma.inventoryBalance.findMany({
        include: {
          sku: true,
          warehouse: true
        }
      });
      
      return allData;
    };

    // Mock large dataset
    const mockLargeDataset = async () => {
      const count = await prisma.inventoryBalance.count();
      
      // Simulate memory usage calculation
      const avgRecordSize = 1024; // 1KB per record
      const memoryUsage = count * avgRecordSize;
      const maxMemory = 512 * 1024 * 1024; // 512MB limit
      
      return memoryUsage > maxMemory;
    };

    const wouldExceedMemory = await mockLargeDataset();
    
    // This should fail - large exports should use pagination
    expect(wouldExceedMemory).toBe(false);
  });

  test('SHOULD FAIL: Unbounded query results', async () => {
    const searchInventory = async (searchTerm: string) => {
      // BUG: No limit on results
      return prisma.inventoryBalance.findMany({
        where: {
          OR: [
            { sku: { name: { contains: searchTerm } } },
            { batchLotNumber: { contains: searchTerm } }
          ]
        },
        include: {
          sku: true,
          warehouse: true,
          transactions: true // Could be thousands per item!
        }
      });
    };

    // Test with broad search term
    const getResultCount = async () => {
      // Simulate counting potential results
      const count = await prisma.inventoryBalance.count({
        where: {
          OR: [
            { sku: { name: { contains: 'e' } } }, // Very common letter
            { batchLotNumber: { contains: 'e' } }
          ]
        }
      });
      return count;
    };

    const resultCount = await getResultCount();
    const hasLimit = resultCount <= 100; // Should have reasonable limit
    
    // This should fail - queries should be limited
    expect(hasLimit).toBe(true);
  });

  test('SHOULD FAIL: Memory leak in file processing', async () => {
    let memoryLeaks: any[] = [];
    
    const processExcelFile = async (fileBuffer: Buffer) => {
      // BUG: Doesn't clean up resources
      const workbook = { data: fileBuffer, sheets: [] as any[] };
      
      // Process sheets
      for (let i = 0; i < 10; i++) {
        const sheet = { 
          data: new Array(10000).fill(0).map(() => new Array(100).fill('data')),
          formulas: {},
          styles: {}
        };
        workbook.sheets.push(sheet);
        memoryLeaks.push(sheet); // References kept!
      }
      
      // BUG: No cleanup
      return workbook;
    };

    // Process multiple files
    for (let i = 0; i < 5; i++) {
      const buffer = Buffer.alloc(1024 * 1024); // 1MB file
      await processExcelFile(buffer);
    }

    // Check if memory is accumulating
    expect(memoryLeaks.length).toBe(0); // Should clean up after processing
  });

  test('SHOULD FAIL: Infinite loop in recursive calculations', async () => {
    const calculateNestedCosts = async (itemId: string, visited = new Set()): Promise<number> => {
      // BUG: No cycle detection
      if (visited.has(itemId)) {
        return 0; // This check might be missing!
      }
      
      visited.add(itemId);
      
      // Get dependencies
      const item = { 
        id: itemId, 
        baseCost: 10,
        dependencies: ['item2', 'item3']
      };
      
      let totalCost = item.baseCost;
      
      // Recursive calculation without proper termination
      for (const depId of item.dependencies) {
        totalCost += await calculateNestedCosts(depId, visited);
      }
      
      return totalCost;
    };

    // Test with circular dependency
    let errorCaught = false;
    try {
      // This could cause infinite recursion
      await calculateNestedCosts('item1');
    } catch (error) {
      errorCaught = true;
    }

    // Should handle circular dependencies
    expect(errorCaught).toBe(false);
  });

  test('SHOULD FAIL: Database connection pool exhaustion', async () => {
    const connections: any[] = [];
    
    // Simulate creating many concurrent connections
    const createManyConnections = async () => {
      const promises = [];
      
      // Try to create 200 concurrent operations
      for (let i = 0; i < 200; i++) {
        promises.push(
          prisma.$transaction(async (tx) => {
            // Simulate long-running transaction
            await new Promise(resolve => setTimeout(resolve, 5000));
            
            return tx.inventoryBalance.findMany({
              take: 10
            });
          }).catch(err => ({ error: err.message }))
        );
      }
      
      return Promise.all(promises);
    };

    const results = await createManyConnections();
    const errors = results.filter(r => 'error' in r);
    
    // Should handle connection pool limits gracefully
    expect(errors.length).toBe(0);
  });

  test('SHOULD FAIL: Regex catastrophic backtracking', async () => {
    const validateBatchNumber = (input: string) => {
      // BUG: Vulnerable regex pattern
      const pattern = /^([a-zA-Z]+)+$/;
      return pattern.test(input);
    };

    // Input that causes catastrophic backtracking
    const maliciousInput = 'a'.repeat(30) + '!';
    
    const startTime = Date.now();
    let timedOut = false;
    
    // Set timeout for regex execution
    const timeoutPromise = new Promise(resolve => 
      setTimeout(() => {
        timedOut = true;
        resolve(false);
      }, 1000)
    );
    
    const validationPromise = new Promise(resolve => 
      resolve(validateBatchNumber(maliciousInput))
    );
    
    await Promise.race([timeoutPromise, validationPromise]);
    const duration = Date.now() - startTime;
    
    // Should complete quickly (under 100ms)
    expect(duration).toBeLessThan(100);
    expect(timedOut).toBe(false);
  });

  test('SHOULD FAIL: Unbounded array growth', async () => {
    const processTransactionHistory = async (skuId: string) => {
      const history: any[] = [];
      
      // BUG: No limit on history size
      const transactions = await prisma.inventoryTransaction.findMany({
        where: { skuId },
        orderBy: { createdAt: 'desc' }
      });
      
      // Process each transaction
      for (const tx of transactions) {
        // Add transaction
        history.push(tx);
        
        // Add calculated states (memory intensive)
        history.push({
          ...tx,
          calculatedBalance: new Array(1000).fill(0),
          metadata: new Array(1000).fill({ data: 'metadata' })
        });
      }
      
      return history;
    };

    // Check memory usage
    const checkMemoryUsage = (data: any[]) => {
      const jsonSize = JSON.stringify(data).length;
      const maxSize = 50 * 1024 * 1024; // 50MB limit
      return jsonSize < maxSize;
    };

    // Simulate processing SKU with many transactions
    const history: any[] = [];
    for (let i = 0; i < 10000; i++) {
      history.push({
        id: i,
        data: new Array(100).fill('data')
      });
    }

    const isWithinLimit = checkMemoryUsage(history);
    
    // Should enforce memory limits
    expect(isWithinLimit).toBe(true);
  });

  test('SHOULD FAIL: CPU-intensive operations block event loop', async () => {
    const calculateComplexMetrics = (data: number[]) => {
      // BUG: Synchronous CPU-intensive operation
      let result = 0;
      
      // Nested loops causing O(nÂ³) complexity
      for (let i = 0; i < data.length; i++) {
        for (let j = 0; j < data.length; j++) {
          for (let k = 0; k < data.length; k++) {
            result += data[i] * data[j] * data[k];
          }
        }
      }
      
      return result;
    };

    const largeDataset = new Array(100).fill(1);
    const startTime = Date.now();
    
    // This should be async or use worker threads
    calculateComplexMetrics(largeDataset);
    
    const duration = Date.now() - startTime;
    
    // Should complete quickly or be async
    expect(duration).toBeLessThan(100); // Should not block for more than 100ms
  });
});