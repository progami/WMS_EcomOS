import { describe, test, expect, jest } from '@jest/globals';

describe('External API Integration Failures', () => {
  test('Amazon API rate limit handling - validates exponential backoff', async () => {
    // Vulnerable implementation - no backoff
    const vulnerableCallAmazonAPI = async (endpoint: string, retryCount = 0): Promise<any> => {
      // Simulate API call
      const response = {
        status: 429, // Rate limited
        headers: {
          'x-amzn-RequestId': '123',
          'x-amzn-RateLimit-Limit': '10'
        },
        data: {
          errors: [{
            code: 'QuotaExceeded',
            message: 'Request rate exceeded'
          }]
        }
      };

      if (response.status === 429) {
        // BUG: No exponential backoff
        if (retryCount < 3) {
          // Simple retry without delay!
          return vulnerableCallAmazonAPI(endpoint, retryCount + 1);
        }
        throw new Error('Rate limited');
      }

      return response;
    };

    // Secure implementation with exponential backoff
    const secureCallAmazonAPI = async (endpoint: string, retryCount = 0): Promise<any> => {
      const response = {
        status: retryCount < 2 ? 429 : 200, // Succeed on 3rd try
        headers: {
          'x-amzn-RequestId': '123',
          'x-amzn-RateLimit-Limit': '10'
        },
        data: retryCount < 2 ? {
          errors: [{
            code: 'QuotaExceeded',
            message: 'Request rate exceeded'
          }]
        } : {
          orders: []
        }
      };

      if (response.status === 429) {
        if (retryCount < 3) {
          // Exponential backoff: 1s, 2s, 4s
          const delay = Math.pow(2, retryCount) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
          return secureCallAmazonAPI(endpoint, retryCount + 1);
        }
        throw new Error('Rate limited');
      }

      return response;
    };

    // Test vulnerable implementation
    let vulnerableError = false;
    const vulnerableStartTime = Date.now();
    
    try {
      await vulnerableCallAmazonAPI('/orders/v0/orders');
    } catch (error) {
      vulnerableError = true;
    }
    
    const vulnerableDuration = Date.now() - vulnerableStartTime;
    
    // Vulnerable implementation fails quickly without backoff
    expect(vulnerableError).toBe(true);
    expect(vulnerableDuration).toBeLessThan(100); // No delays
    
    // Test secure implementation
    let secureError = false;
    const secureStartTime = Date.now();
    let secureResponse;
    
    try {
      secureResponse = await secureCallAmazonAPI('/orders/v0/orders');
    } catch (error) {
      secureError = true;
    }
    
    const secureDuration = Date.now() - secureStartTime;
    
    // Secure implementation succeeds with proper backoff
    expect(secureError).toBe(false);
    expect(secureDuration).toBeGreaterThan(3000); // 1s + 2s minimum
    expect(secureResponse?.status).toBe(200);
  });

  test('Network timeout handling - validates timeout configuration', async () => {
    // Vulnerable implementation - no timeout
    const vulnerableFetchExternalData = async (url: string) => {
      // BUG: No timeout configured
      const controller = new AbortController();
      
      // Simulate slow response
      const slowResponse = new Promise((resolve) => {
        setTimeout(() => resolve({ data: 'success' }), 30000); // 30 second response
      });

      return slowResponse;
    };

    // Secure implementation with timeout
    const secureFetchExternalData = async (url: string, timeoutMs = 5000) => {
      const controller = new AbortController();
      
      // Set timeout
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      
      try {
        // Simulate fetch with abort controller
        const response = await Promise.race([
          new Promise((resolve, reject) => {
            if (controller.signal.aborted) {
              reject(new Error('Request timeout'));
            }
            // Simulate slow response
            setTimeout(() => {
              if (!controller.signal.aborted) {
                resolve({ data: 'success' });
              }
            }, 30000);
            
            controller.signal.addEventListener('abort', () => {
              reject(new Error('Request timeout'));
            });
          }),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Request timeout')), timeoutMs)
          )
        ]);
        
        clearTimeout(timeoutId);
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    };

    // Test vulnerable implementation
    let vulnerableTimedOut = false;
    const vulnerableTimeoutPromise = new Promise((resolve) => {
      setTimeout(() => {
        vulnerableTimedOut = true;
        resolve('timeout');
      }, 5000);
    });

    const vulnerableResult = await Promise.race([
      vulnerableFetchExternalData('https://slow-api.example.com'),
      vulnerableTimeoutPromise
    ]);

    // Vulnerable implementation doesn't timeout on its own
    expect(vulnerableResult).toBe('timeout');
    expect(vulnerableTimedOut).toBe(true);

    // Test secure implementation
    let secureError = null;
    try {
      await secureFetchExternalData('https://slow-api.example.com', 1000);
    } catch (error: any) {
      secureError = error;
    }

    // Secure implementation times out properly
    expect(secureError).not.toBeNull();
    expect(secureError?.message).toContain('timeout');
  });

  test('Circuit breaker pattern - validates failure threshold', async () => {
    // Vulnerable implementation - no circuit breaker
    let vulnerableFailureCount = 0;
    
    const vulnerableUnreliableAPICall = async () => {
      vulnerableFailureCount++;
      throw new Error('Service unavailable');
    };

    const vulnerableMakeAPICall = async () => {
      // BUG: No circuit breaker - keeps calling failed service
      try {
        return await vulnerableUnreliableAPICall();
      } catch (error) {
        throw error;
      }
    };

    // Secure implementation with circuit breaker
    let secureFailureCount = 0;
    let consecutiveFailures = 0;
    let circuitOpen = false;
    let circuitOpenUntil = 0;
    const failureThreshold = 5;
    const circuitResetTime = 60000; // 1 minute
    
    const secureUnreliableAPICall = async () => {
      secureFailureCount++;
      throw new Error('Service unavailable');
    };

    const secureMakeAPICall = async () => {
      // Check if circuit is open
      if (circuitOpen) {
        if (Date.now() < circuitOpenUntil) {
          throw new Error('Circuit breaker is open');
        } else {
          // Try to close circuit
          circuitOpen = false;
          consecutiveFailures = 0;
        }
      }

      try {
        const result = await secureUnreliableAPICall();
        consecutiveFailures = 0; // Reset on success
        return result;
      } catch (error) {
        consecutiveFailures++;
        
        if (consecutiveFailures >= failureThreshold) {
          circuitOpen = true;
          circuitOpenUntil = Date.now() + circuitResetTime;
          throw new Error('Circuit breaker is open');
        }
        
        throw error;
      }
    };

    // Test vulnerable implementation
    const vulnerableResults = [];
    for (let i = 0; i < 10; i++) {
      try {
        await vulnerableMakeAPICall();
        vulnerableResults.push('success');
      } catch (error) {
        vulnerableResults.push('failure');
      }
    }

    // Vulnerable implementation calls the service every time
    expect(vulnerableFailureCount).toBe(10);

    // Test secure implementation
    const secureResults = [];
    for (let i = 0; i < 10; i++) {
      try {
        await secureMakeAPICall();
        secureResults.push('success');
      } catch (error: any) {
        secureResults.push(error.message.includes('Circuit breaker') ? 'circuit-open' : 'failure');
      }
    }

    // Secure implementation stops calling after threshold
    expect(secureFailureCount).toBeLessThanOrEqual(failureThreshold);
    expect(secureResults.filter(r => r === 'circuit-open').length).toBeGreaterThan(0);
  });

  test('Invalid API response handling - validates error handling', async () => {
    // Vulnerable implementation - no validation
    const vulnerableProcessAPIResponse = (response: any) => {
      // BUG: No validation of response structure
      return {
        orderId: response.data.order.id,
        items: response.data.order.items.map((item: any) => ({
          sku: item.sku,
          quantity: item.quantity,
          price: item.price.amount
        })),
        total: response.data.order.summary.total
      };
    };

    // Secure implementation with validation
    const secureProcessAPIResponse = (response: any) => {
      // Validate response structure
      if (!response || typeof response !== 'object') {
        return { orderId: null, items: [], total: 0, error: 'Invalid response' };
      }
      
      if (!response.data || typeof response.data !== 'object') {
        return { orderId: null, items: [], total: 0, error: 'Missing data' };
      }
      
      if (!response.data.order || typeof response.data.order !== 'object') {
        return { orderId: null, items: [], total: 0, error: 'Missing order' };
      }
      
      const order = response.data.order;
      
      return {
        orderId: order.id || null,
        items: Array.isArray(order.items) ? order.items.map((item: any) => ({
          sku: item?.sku || '',
          quantity: item?.quantity || 0,
          price: item?.price?.amount || 0
        })) : [],
        total: order.summary?.total || 0
      };
    };

    // Test with various invalid responses
    const invalidResponses = [
      null,
      undefined,
      {},
      { data: null },
      { data: {} },
      { data: { order: null } },
      { data: { order: { items: null } } },
      { data: { order: { items: [{ price: null }] } } }
    ];

    // Test vulnerable implementation
    let vulnerableErrors = 0;
    for (const response of invalidResponses) {
      try {
        vulnerableProcessAPIResponse(response);
      } catch (error) {
        vulnerableErrors++;
      }
    }

    // Vulnerable implementation throws errors
    expect(vulnerableErrors).toBe(invalidResponses.length);

    // Test secure implementation
    let secureErrors = 0;
    for (const response of invalidResponses) {
      try {
        const result = secureProcessAPIResponse(response);
        // Check that it returns safe defaults
        expect(result).toHaveProperty('orderId');
        expect(result).toHaveProperty('items');
        expect(result).toHaveProperty('total');
      } catch (error) {
        secureErrors++;
      }
    }

    // Secure implementation handles all cases gracefully
    expect(secureErrors).toBe(0);
  });

  test('API key rotation during request - validates key freshness', async () => {
    // Vulnerable implementation
    let vulnerableCurrentAPIKey = 'key-version-1';
    
    const vulnerableMakeAuthenticatedRequest = async (url: string) => {
      // BUG: Reads API key at start of long operation
      const apiKey = vulnerableCurrentAPIKey;
      
      // Simulate long processing
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // API key might have rotated during processing
      return {
        url,
        headers: {
          'Authorization': `Bearer ${apiKey}`
        },
        keyUsed: apiKey
      };
    };

    // Secure implementation
    let secureCurrentAPIKey = 'key-version-1';
    
    const secureMakeAuthenticatedRequest = async (url: string) => {
      // Simulate long processing
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Read API key just before making request
      const apiKey = secureCurrentAPIKey;
      
      return {
        url,
        headers: {
          'Authorization': `Bearer ${apiKey}`
        },
        keyUsed: apiKey
      };
    };

    // Test vulnerable implementation
    const vulnerableRequestPromise = vulnerableMakeAuthenticatedRequest('/api/external/data');
    
    // Rotate key while request is in progress
    setTimeout(() => {
      vulnerableCurrentAPIKey = 'key-version-2';
    }, 1000);

    const vulnerableResponse = await vulnerableRequestPromise;
    
    // Vulnerable implementation uses old key
    expect(vulnerableResponse.keyUsed).toBe('key-version-1');
    expect(vulnerableCurrentAPIKey).toBe('key-version-2');

    // Test secure implementation
    const secureRequestPromise = secureMakeAuthenticatedRequest('/api/external/data');
    
    // Rotate key while request is in progress
    setTimeout(() => {
      secureCurrentAPIKey = 'key-version-2';
    }, 1000);

    const secureResponse = await secureRequestPromise;
    
    // Secure implementation uses current key
    expect(secureResponse.keyUsed).toBe('key-version-2');
  });

  test('Webhook delivery retry logic - validates retry mechanism', async () => {
    // Vulnerable implementation - no retries
    const vulnerableSendWebhook = async (url: string, payload: any, attempt = 1): Promise<boolean> => {
      // Always fails
      throw new Error('Connection refused');
    };

    const vulnerableDeliverWebhook = async (url: string, payload: any) => {
      try {
        return await vulnerableSendWebhook(url, payload);
      } catch (error) {
        // BUG: Just logs and gives up
        return false;
      }
    };

    // Secure implementation with retries
    const secureSendWebhook = async (url: string, payload: any, attempt = 1): Promise<boolean> => {
      // Simulate failures for first 2 attempts
      if (attempt <= 2) {
        throw new Error('Connection refused');
      }
      return true;
    };

    const secureDeliverWebhook = async (url: string, payload: any) => {
      const maxRetries = 3;
      let lastError;
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          // Exponential backoff
          if (attempt > 1) {
            const delay = Math.pow(2, attempt - 1) * 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
          }
          
          return await secureSendWebhook(url, payload, attempt);
        } catch (error) {
          lastError = error;
          if (attempt === maxRetries) {
            throw lastError;
          }
        }
      }
      
      return false;
    };

    // Test vulnerable implementation
    const vulnerableDelivered = await vulnerableDeliverWebhook('https://customer.com/webhook', {
      event: 'inventory.updated',
      data: { sku: 'TEST-001', quantity: 100 }
    });

    // Vulnerable implementation gives up immediately
    expect(vulnerableDelivered).toBe(false);

    // Test secure implementation
    const secureStartTime = Date.now();
    const secureDelivered = await secureDeliverWebhook('https://customer.com/webhook', {
      event: 'inventory.updated',
      data: { sku: 'TEST-001', quantity: 100 }
    });
    const secureDuration = Date.now() - secureStartTime;

    // Secure implementation retries and succeeds
    expect(secureDelivered).toBe(true);
    expect(secureDuration).toBeGreaterThan(2000); // At least 2s delay for retries
  });

  test('Partial API response handling - validates failure recovery', async () => {
    const fetchInventoryBatch = async (skus: string[]) => {
      // Simulate API that returns partial results
      const results = skus.slice(0, Math.floor(skus.length / 2)).map(sku => ({
        sku,
        quantity: Math.floor(Math.random() * 100)
      }));

      return {
        success: results,
        failed: skus.slice(Math.floor(skus.length / 2))
      };
    };

    // Vulnerable implementation - ignores failures
    const vulnerableUpdateInventoryFromAPI = async (skus: string[]) => {
      const response = await fetchInventoryBatch(skus);
      
      // BUG: Only processes successful items, ignores failures
      return response.success;
    };

    // Secure implementation - handles partial failures
    const secureUpdateInventoryFromAPI = async (skus: string[]) => {
      const response = await fetchInventoryBatch(skus);
      const allResults = [...response.success];
      
      // Retry failed items
      if (response.failed.length > 0) {
        // In real implementation, might retry with backoff
        // For test, we'll add default values for failed items
        const failedResults = response.failed.map(sku => ({
          sku,
          quantity: 0,
          error: 'Failed to fetch'
        }));
        
        allResults.push(...failedResults);
      }
      
      return allResults;
    };

    const skusToUpdate = ['SKU-1', 'SKU-2', 'SKU-3', 'SKU-4'];
    
    // Test vulnerable implementation
    const vulnerableUpdated = await vulnerableUpdateInventoryFromAPI(skusToUpdate);
    
    // Vulnerable implementation only returns half the items
    expect(vulnerableUpdated.length).toBe(Math.floor(skusToUpdate.length / 2));
    
    // Test secure implementation
    const secureUpdated = await secureUpdateInventoryFromAPI(skusToUpdate);
    
    // Secure implementation handles all items
    expect(secureUpdated.length).toBe(skusToUpdate.length);
    
    // Check that failed items are marked
    const failedItems = secureUpdated.filter(item => 'error' in item);
    expect(failedItems.length).toBe(Math.ceil(skusToUpdate.length / 2));
  });

  test('API versioning conflicts - validates version compatibility', async () => {
    const apiVersions = {
      v1: {
        parseOrder: (data: any) => ({
          orderId: data.order_id,
          items: data.line_items
        })
      },
      v2: {
        parseOrder: (data: any) => ({
          orderId: data.id,
          items: data.items
        })
      }
    };

    // Vulnerable implementation - ignores version
    const vulnerableProcessOrder = (data: any, version = 'v2') => {
      // BUG: No version checking
      return apiVersions.v2.parseOrder(data);
    };

    // Secure implementation - handles versions
    const secureProcessOrder = (data: any, version = 'v2') => {
      // Detect version from data structure
      let detectedVersion = version;
      if ('order_id' in data && 'line_items' in data) {
        detectedVersion = 'v1';
      } else if ('id' in data && 'items' in data) {
        detectedVersion = 'v2';
      }
      
      // Use appropriate parser
      if (detectedVersion === 'v1' && apiVersions.v1) {
        return apiVersions.v1.parseOrder(data);
      } else if (detectedVersion === 'v2' && apiVersions.v2) {
        return apiVersions.v2.parseOrder(data);
      }
      
      // Fallback with safe defaults
      return {
        orderId: data.order_id || data.id || null,
        items: data.line_items || data.items || []
      };
    };

    // V1 format data
    const v1Data = {
      order_id: '12345',
      line_items: [{ sku: 'TEST-001' }]
    };

    // Test vulnerable implementation
    const vulnerableResult = vulnerableProcessOrder(v1Data);
    
    // Vulnerable implementation returns undefined values
    expect(vulnerableResult.orderId).toBeUndefined();
    expect(vulnerableResult.items).toBeUndefined();

    // Test secure implementation
    const secureResult = secureProcessOrder(v1Data);
    
    // Secure implementation correctly parses v1 data
    expect(secureResult.orderId).toBe('12345');
    expect(secureResult.items).toEqual([{ sku: 'TEST-001' }]);
    
    // Test with v2 data
    const v2Data = {
      id: '67890',
      items: [{ sku: 'TEST-002' }]
    };
    
    const secureV2Result = secureProcessOrder(v2Data);
    expect(secureV2Result.orderId).toBe('67890');
    expect(secureV2Result.items).toEqual([{ sku: 'TEST-002' }]);
  });

  test('OAuth token refresh race condition - validates token synchronization', async () => {
    // Vulnerable implementation - no synchronization
    let vulnerableAccessToken = 'expired-token';
    let vulnerableRefreshing = false;
    let vulnerableRefreshCount = 0;
    
    const vulnerableRefreshToken = async () => {
      // BUG: No lock on refresh process
      if (vulnerableRefreshing) return vulnerableAccessToken;
      
      vulnerableRefreshing = true;
      vulnerableRefreshCount++;
      await new Promise(resolve => setTimeout(resolve, 100));
      vulnerableAccessToken = `new-token-${Date.now()}`;
      vulnerableRefreshing = false;
      
      return vulnerableAccessToken;
    };

    const vulnerableMakeAuthenticatedCall = async () => {
      if (vulnerableAccessToken === 'expired-token') {
        await vulnerableRefreshToken();
      }
      return { token: vulnerableAccessToken };
    };

    // Secure implementation with proper locking
    let secureAccessToken = 'expired-token';
    let secureRefreshPromise: Promise<string> | null = null;
    let secureRefreshCount = 0;
    
    const secureRefreshToken = async () => {
      // If already refreshing, return the existing promise
      if (secureRefreshPromise) {
        return secureRefreshPromise;
      }
      
      // Create new refresh promise
      secureRefreshPromise = (async () => {
        secureRefreshCount++;
        await new Promise(resolve => setTimeout(resolve, 100));
        const newToken = `new-token-${Date.now()}`;
        secureAccessToken = newToken;
        return newToken;
      })();
      
      try {
        const token = await secureRefreshPromise;
        return token;
      } finally {
        secureRefreshPromise = null;
      }
    };

    const secureMakeAuthenticatedCall = async () => {
      if (secureAccessToken === 'expired-token') {
        await secureRefreshToken();
      }
      return { token: secureAccessToken };
    };

    // Test vulnerable implementation
    const vulnerableResults = await Promise.all([
      vulnerableMakeAuthenticatedCall(),
      vulnerableMakeAuthenticatedCall(),
      vulnerableMakeAuthenticatedCall()
    ]);

    const vulnerableUniqueTokens = new Set(vulnerableResults.map(r => r.token));
    
    // Vulnerable implementation might refresh multiple times
    // (race condition may or may not occur depending on timing)
    
    // Test secure implementation
    secureAccessToken = 'expired-token'; // Reset
    const secureResults = await Promise.all([
      secureMakeAuthenticatedCall(),
      secureMakeAuthenticatedCall(),
      secureMakeAuthenticatedCall()
    ]);

    const secureUniqueTokens = new Set(secureResults.map(r => r.token));
    
    // Secure implementation should only refresh once
    expect(secureRefreshCount).toBe(1);
    expect(secureUniqueTokens.size).toBe(1);
    
    // All calls should have the same token
    const [firstToken] = secureUniqueTokens;
    expect(firstToken).toMatch(/^new-token-\d+$/);
  });
});