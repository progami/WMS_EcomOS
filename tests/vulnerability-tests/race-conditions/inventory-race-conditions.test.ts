import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { PrismaClient } from '@prisma/client';
import { createInventoryTransaction } from '@/lib/inventory-service';

const prisma = new PrismaClient();

describe('Inventory Race Condition Vulnerabilities', () => {
  let testWarehouseId: string;
  let testSkuId: string;
  let testBatchId: string;
  let testUserId: string;

  beforeEach(async () => {
    // Create test user first
    const user = await prisma.user.create({
      data: {
        email: `testrace-${Date.now()}@example.com`,
        fullName: 'Test User Race',
        passwordHash: 'hashedpassword',
        role: 'staff'
      }
    });
    testUserId = user.id;

    // Setup test data
    const warehouse = await prisma.warehouse.create({
      data: {
        name: 'Test Warehouse Race',
        code: 'TWR',
        address: 'Test Address',
        isActive: true
      }
    });
    testWarehouseId = warehouse.id;

    const sku = await prisma.sku.create({
      data: {
        skuCode: 'SKU-RACE',
        description: 'Test SKU Race',
        packSize: 1,
        unitsPerCarton: 10,
        isActive: true
      }
    });
    testSkuId = sku.id;

    // Create initial inventory with specific batch
    const transaction = await prisma.inventoryTransaction.create({
      data: {
        transactionId: `TX-RACE-${Date.now()}`,
        transactionType: 'RECEIVE',
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        batchLot: 'BATCH-RACE-001',
        cartonsIn: 100,
        cartonsOut: 0,
        storagePalletsIn: 10,
        shippingPalletsOut: 0,
        transactionDate: new Date(),
        createdById: testUserId
      }
    });
    testBatchId = transaction.id;

    // Create inventory balance
    await prisma.inventoryBalance.create({
      data: {
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        batchLot: 'BATCH-RACE-001',
        currentCartons: 100,
        currentPallets: 10,
        currentUnits: 1000
      }
    });
  });

  afterEach(async () => {
    // Cleanup
    await prisma.inventoryBalance.deleteMany({});
    await prisma.inventoryTransaction.deleteMany({});
    await prisma.sku.deleteMany({});
    await prisma.warehouse.deleteMany({});
    await prisma.user.deleteMany({});
  });

  test('SHOULD FAIL: Concurrent shipments can create negative inventory', async () => {
    // This test demonstrates that without proper transaction isolation,
    // multiple concurrent shipments can deplete the same batch beyond available quantity

    const shipmentPromises = [];
    
    // Create 5 concurrent shipments, each trying to ship 300 units
    // Total: 1500 units, but we only have 1000 units available
    for (let i = 0; i < 5; i++) {
      shipmentPromises.push(
        createInventoryTransaction({
          type: 'ship',
          warehouseId: testWarehouseId,
          skuId: testSkuId,
          palletCount: 3,
          unitsPerPallet: 100,
          totalUnits: 300,
          batchLotNumber: 'BATCH-RACE-001',
          transactionDate: new Date()
        })
      );
    }

    // Execute all shipments concurrently
    const results = await Promise.allSettled(shipmentPromises);
    
    // Check final inventory balance
    const finalBalance = await prisma.inventoryBalance.findFirst({
      where: {
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        batchLot: 'BATCH-RACE-001'
      }
    });

    // This assertion SHOULD FAIL because the app allows negative inventory
    expect(finalBalance?.currentUnits).toBeGreaterThanOrEqual(0);
    
    // Count successful transactions
    const successfulTransactions = results.filter(r => r.status === 'fulfilled').length;
    
    // Maximum should be 3 transactions (1000 units / 300 units per transaction)
    // But without proper locking, more might succeed
    expect(successfulTransactions).toBeLessThanOrEqual(3);
  });

  test('SHOULD FAIL: Parallel inventory adjustments cause data inconsistency', async () => {
    // Multiple concurrent adjustments can lead to lost updates

    const adjustmentPromises = [];
    
    // 10 concurrent adjustments, each adding 50 units
    for (let i = 0; i < 10; i++) {
      adjustmentPromises.push(
        prisma.$transaction(async (tx) => {
          // Simulate read-modify-write without proper locking
          const current = await tx.inventoryBalance.findFirst({
            where: {
              warehouseId: testWarehouseId,
              skuId: testSkuId,
              batchLot: 'BATCH-RACE-001'
            }
          });

          // Artificial delay to increase race condition likelihood
          await new Promise(resolve => setTimeout(resolve, 10));

          await tx.inventoryBalance.update({
            where: { id: current!.id },
            data: {
              currentUnits: current!.currentUnits + 50
            }
          });

          await tx.inventoryTransaction.create({
            data: {
              transactionId: `TX-ADJUST-${Date.now()}-${Math.random()}`,
              transactionType: 'ADJUST_IN',
              warehouseId: testWarehouseId,
              skuId: testSkuId,
              batchLot: 'BATCH-RACE-001',
              cartonsIn: 5,
              cartonsOut: 0,
              storagePalletsIn: 1,
              shippingPalletsOut: 0,
              transactionDate: new Date(),
              createdById: 'test-user'
            }
          });
        })
      );
    }

    await Promise.all(adjustmentPromises);

    const finalBalance = await prisma.inventoryBalance.findFirst({
      where: {
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        batchLot: 'BATCH-RACE-001'
      }
    });

    // Should be 1000 + (10 * 50) = 1500
    // But due to race conditions, some updates might be lost
    expect(finalBalance?.currentUnits).toBe(1500);
  });

  test('SHOULD FAIL: Concurrent batch splitting causes duplicate batch entries', async () => {
    // When splitting a batch concurrently, duplicate batch entries can be created

    const splitPromises = [];
    
    // 3 concurrent attempts to split the same batch
    for (let i = 0; i < 3; i++) {
      splitPromises.push(
        prisma.$transaction(async (tx) => {
          // Check if batch exists
          const existingBatch = await tx.inventoryBalance.findFirst({
            where: {
              warehouseId: testWarehouseId,
              skuId: testSkuId,
              batchLot: 'BATCH-RACE-001'
            }
          });

          if (existingBatch && existingBatch.currentUnits >= 500) {
            // Create new split batch
            await tx.inventoryBalance.create({
              data: {
                warehouseId: testWarehouseId,
                skuId: testSkuId,
                batchLot: `BATCH-RACE-001-SPLIT-${i}`,
                currentCartons: 50,
                currentPallets: 5,
                currentUnits: 500
              }
            });

            // Update original batch
            await tx.inventoryBalance.update({
              where: { id: existingBatch.id },
              data: {
                currentUnits: existingBatch.currentUnits - 500,
                currentPallets: existingBatch.currentPallets - 5
              }
            });
          }
        })
      );
    }

    const results = await Promise.allSettled(splitPromises);
    
    // Check total inventory
    const allBatches = await prisma.inventoryBalance.findMany({
      where: {
        warehouseId: testWarehouseId,
        skuId: testSkuId
      }
    });

    const totalUnits = allBatches.reduce((sum, batch) => sum + batch.currentUnits, 0);
    
    // Total units should remain 1000, but race conditions might create extra units
    expect(totalUnits).toBe(1000);
    
    // Should have maximum 2 successful splits (1000 units, 500 per split)
    const splitBatches = allBatches.filter(b => b.batchLot.includes('SPLIT'));
    expect(splitBatches.length).toBeLessThanOrEqual(2);
  });

  test('SHOULD FAIL: Race condition in FIFO batch selection', async () => {
    // Create multiple batches with different dates
    const batch2 = await prisma.inventoryBalance.create({
      data: {
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        batchLot: 'BATCH-RACE-002',
        currentCartons: 50,
        currentPallets: 5,
        currentUnits: 500,
        lastUpdated: new Date(Date.now() + 1000) // Newer batch
      }
    });

    // Multiple concurrent shipments that should use FIFO
    const shipmentPromises = [];
    
    for (let i = 0; i < 5; i++) {
      shipmentPromises.push(
        (async () => {
          // Get oldest batch (FIFO)
          const oldestBatch = await prisma.inventoryBalance.findFirst({
            where: {
              warehouseId: testWarehouseId,
              skuId: testSkuId,
              currentUnits: { gt: 0 }
            },
            orderBy: { lastUpdated: 'asc' }
          });

          if (oldestBatch && oldestBatch.currentUnits >= 200) {
            await prisma.inventoryBalance.update({
              where: { id: oldestBatch.id },
              data: {
                currentUnits: oldestBatch.currentUnits - 200
              }
            });

            return oldestBatch.batchLot;
          }
          return null;
        })()
      );
    }

    const results = await Promise.all(shipmentPromises);
    
    // Check which batches were used
    const batch1Used = results.filter(r => r === 'BATCH-RACE-001').length;
    const batch2Used = results.filter(r => r === 'BATCH-RACE-002').length;
    
    // FIFO should use batch 1 first (1000 units / 200 = 5 shipments)
    // But race conditions might cause newer batch to be used
    expect(batch2Used).toBe(0); // Should not use newer batch
    expect(batch1Used).toBe(5); // All should use older batch
  });
});