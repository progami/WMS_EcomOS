import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { PrismaClient } from '@prisma/client';
import { createInventoryTransaction } from '@/lib/inventory-service';

const prisma = new PrismaClient();

describe('Inventory Race Condition Vulnerabilities', () => {
  let testWarehouseId: string;
  let testSkuId: string;
  let testBatchId: string;

  beforeEach(async () => {
    // Setup test data
    const warehouse = await prisma.warehouse.create({
      data: {
        name: 'Test Warehouse Race',
        code: 'TWR',
        address: 'Test Address',
        status: 'active'
      }
    });
    testWarehouseId = warehouse.id;

    const sku = await prisma.sku.create({
      data: {
        name: 'Test SKU Race',
        code: 'SKU-RACE',
        barcode: 'RACE123',
        status: 'active'
      }
    });
    testSkuId = sku.id;

    // Create initial inventory with specific batch
    const transaction = await prisma.inventoryTransaction.create({
      data: {
        type: 'receive',
        status: 'completed',
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        palletCount: 10,
        unitsPerPallet: 100,
        totalUnits: 1000,
        batchLotNumber: 'BATCH-RACE-001',
        transactionDate: new Date()
      }
    });
    testBatchId = transaction.id;

    // Create inventory balance
    await prisma.inventoryBalance.create({
      data: {
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        palletCount: 10,
        unitsPerPallet: 100,
        totalUnits: 1000,
        batchLotNumber: 'BATCH-RACE-001'
      }
    });
  });

  afterEach(async () => {
    // Cleanup
    await prisma.inventoryBalance.deleteMany({});
    await prisma.inventoryTransaction.deleteMany({});
    await prisma.sku.deleteMany({});
    await prisma.warehouse.deleteMany({});
  });

  test('SHOULD FAIL: Concurrent shipments can create negative inventory', async () => {
    // This test demonstrates that without proper transaction isolation,
    // multiple concurrent shipments can deplete the same batch beyond available quantity

    const shipmentPromises = [];
    
    // Create 5 concurrent shipments, each trying to ship 300 units
    // Total: 1500 units, but we only have 1000 units available
    for (let i = 0; i < 5; i++) {
      shipmentPromises.push(
        createInventoryTransaction({
          type: 'ship',
          warehouseId: testWarehouseId,
          skuId: testSkuId,
          palletCount: 3,
          unitsPerPallet: 100,
          totalUnits: 300,
          batchLotNumber: 'BATCH-RACE-001',
          transactionDate: new Date()
        })
      );
    }

    // Execute all shipments concurrently
    const results = await Promise.allSettled(shipmentPromises);
    
    // Check final inventory balance
    const finalBalance = await prisma.inventoryBalance.findFirst({
      where: {
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        batchLotNumber: 'BATCH-RACE-001'
      }
    });

    // This assertion SHOULD FAIL because the app allows negative inventory
    expect(finalBalance?.totalUnits).toBeGreaterThanOrEqual(0);
    
    // Count successful transactions
    const successfulTransactions = results.filter(r => r.status === 'fulfilled').length;
    
    // Maximum should be 3 transactions (1000 units / 300 units per transaction)
    // But without proper locking, more might succeed
    expect(successfulTransactions).toBeLessThanOrEqual(3);
  });

  test('SHOULD FAIL: Parallel inventory adjustments cause data inconsistency', async () => {
    // Multiple concurrent adjustments can lead to lost updates

    const adjustmentPromises = [];
    
    // 10 concurrent adjustments, each adding 50 units
    for (let i = 0; i < 10; i++) {
      adjustmentPromises.push(
        prisma.$transaction(async (tx) => {
          // Simulate read-modify-write without proper locking
          const current = await tx.inventoryBalance.findFirst({
            where: {
              warehouseId: testWarehouseId,
              skuId: testSkuId,
              batchLotNumber: 'BATCH-RACE-001'
            }
          });

          // Artificial delay to increase race condition likelihood
          await new Promise(resolve => setTimeout(resolve, 10));

          await tx.inventoryBalance.update({
            where: { id: current!.id },
            data: {
              totalUnits: current!.totalUnits + 50
            }
          });

          await tx.inventoryTransaction.create({
            data: {
              type: 'adjust',
              status: 'completed',
              warehouseId: testWarehouseId,
              skuId: testSkuId,
              palletCount: 0,
              unitsPerPallet: 100,
              totalUnits: 50,
              batchLotNumber: 'BATCH-RACE-001',
              transactionDate: new Date()
            }
          });
        })
      );
    }

    await Promise.all(adjustmentPromises);

    const finalBalance = await prisma.inventoryBalance.findFirst({
      where: {
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        batchLotNumber: 'BATCH-RACE-001'
      }
    });

    // Should be 1000 + (10 * 50) = 1500
    // But due to race conditions, some updates might be lost
    expect(finalBalance?.totalUnits).toBe(1500);
  });

  test('SHOULD FAIL: Concurrent batch splitting causes duplicate batch entries', async () => {
    // When splitting a batch concurrently, duplicate batch entries can be created

    const splitPromises = [];
    
    // 3 concurrent attempts to split the same batch
    for (let i = 0; i < 3; i++) {
      splitPromises.push(
        prisma.$transaction(async (tx) => {
          // Check if batch exists
          const existingBatch = await tx.inventoryBalance.findFirst({
            where: {
              warehouseId: testWarehouseId,
              skuId: testSkuId,
              batchLotNumber: 'BATCH-RACE-001'
            }
          });

          if (existingBatch && existingBatch.totalUnits >= 500) {
            // Create new split batch
            await tx.inventoryBalance.create({
              data: {
                warehouseId: testWarehouseId,
                skuId: testSkuId,
                palletCount: 5,
                unitsPerPallet: 100,
                totalUnits: 500,
                batchLotNumber: `BATCH-RACE-001-SPLIT-${i}`
              }
            });

            // Update original batch
            await tx.inventoryBalance.update({
              where: { id: existingBatch.id },
              data: {
                totalUnits: existingBatch.totalUnits - 500,
                palletCount: existingBatch.palletCount - 5
              }
            });
          }
        })
      );
    }

    const results = await Promise.allSettled(splitPromises);
    
    // Check total inventory
    const allBatches = await prisma.inventoryBalance.findMany({
      where: {
        warehouseId: testWarehouseId,
        skuId: testSkuId
      }
    });

    const totalUnits = allBatches.reduce((sum, batch) => sum + batch.totalUnits, 0);
    
    // Total units should remain 1000, but race conditions might create extra units
    expect(totalUnits).toBe(1000);
    
    // Should have maximum 2 successful splits (1000 units, 500 per split)
    const splitBatches = allBatches.filter(b => b.batchLotNumber.includes('SPLIT'));
    expect(splitBatches.length).toBeLessThanOrEqual(2);
  });

  test('SHOULD FAIL: Race condition in FIFO batch selection', async () => {
    // Create multiple batches with different dates
    const batch2 = await prisma.inventoryBalance.create({
      data: {
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        palletCount: 5,
        unitsPerPallet: 100,
        totalUnits: 500,
        batchLotNumber: 'BATCH-RACE-002',
        createdAt: new Date(Date.now() + 1000) // Newer batch
      }
    });

    // Multiple concurrent shipments that should use FIFO
    const shipmentPromises = [];
    
    for (let i = 0; i < 5; i++) {
      shipmentPromises.push(
        (async () => {
          // Get oldest batch (FIFO)
          const oldestBatch = await prisma.inventoryBalance.findFirst({
            where: {
              warehouseId: testWarehouseId,
              skuId: testSkuId,
              totalUnits: { gt: 0 }
            },
            orderBy: { createdAt: 'asc' }
          });

          if (oldestBatch && oldestBatch.totalUnits >= 200) {
            await prisma.inventoryBalance.update({
              where: { id: oldestBatch.id },
              data: {
                totalUnits: oldestBatch.totalUnits - 200
              }
            });

            return oldestBatch.batchLotNumber;
          }
          return null;
        })()
      );
    }

    const results = await Promise.all(shipmentPromises);
    
    // Check which batches were used
    const batch1Used = results.filter(r => r === 'BATCH-RACE-001').length;
    const batch2Used = results.filter(r => r === 'BATCH-RACE-002').length;
    
    // FIFO should use batch 1 first (1000 units / 200 = 5 shipments)
    // But race conditions might cause newer batch to be used
    expect(batch2Used).toBe(0); // Should not use newer batch
    expect(batch1Used).toBe(5); // All should use older batch
  });
});