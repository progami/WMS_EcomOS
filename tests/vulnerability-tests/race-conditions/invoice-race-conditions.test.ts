import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

describe('Invoice Generation Race Conditions', () => {
  let testWarehouseId: string;
  let testCustomerId: string;

  beforeEach(async () => {
    const warehouse = await prisma.warehouse.create({
      data: {
        name: 'Test Warehouse Invoice',
        code: 'TWI',
        address: 'Test Address',
        status: 'active'
      }
    });
    testWarehouseId = warehouse.id;

    const user = await prisma.user.create({
      data: {
        email: 'test-invoice@example.com',
        name: 'Test Customer',
        password: 'test',
        role: 'customer'
      }
    });
    testCustomerId = user.id;
  });

  afterEach(async () => {
    await prisma.invoice.deleteMany({});
    await prisma.user.deleteMany({});
    await prisma.warehouse.deleteMany({});
  });

  test('SHOULD FAIL: Concurrent invoice number generation creates duplicates', async () => {
    // Invoice numbers are generated sequentially but without proper locking
    
    const invoicePromises = [];
    
    // Create 10 invoices concurrently
    for (let i = 0; i < 10; i++) {
      invoicePromises.push(
        (async () => {
          // Simulate the typical invoice number generation pattern
          const lastInvoice = await prisma.invoice.findFirst({
            orderBy: { invoiceNumber: 'desc' }
          });
          
          const nextNumber = lastInvoice 
            ? parseInt(lastInvoice.invoiceNumber.replace('INV-', '')) + 1
            : 1;
          
          const invoiceNumber = `INV-${String(nextNumber).padStart(6, '0')}`;
          
          // Small delay to increase race condition likelihood
          await new Promise(resolve => setTimeout(resolve, 5));
          
          return prisma.invoice.create({
            data: {
              invoiceNumber,
              warehouseId: testWarehouseId,
              customerId: testCustomerId,
              status: 'draft',
              issueDate: new Date(),
              dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
              subtotal: 1000,
              taxAmount: 100,
              totalAmount: 1100,
              currency: 'USD'
            }
          });
        })()
      );
    }

    const results = await Promise.allSettled(invoicePromises);
    
    // Check for duplicate invoice numbers
    const invoices = await prisma.invoice.findMany({
      select: { invoiceNumber: true }
    });
    
    const invoiceNumbers = invoices.map(inv => inv.invoiceNumber);
    const uniqueNumbers = new Set(invoiceNumbers);
    
    // This should fail as race conditions create duplicates
    expect(uniqueNumbers.size).toBe(invoiceNumbers.length);
  });

  test('SHOULD FAIL: Concurrent monthly invoice closing causes data loss', async () => {
    // Create multiple draft invoices
    const draftInvoices = [];
    for (let i = 1; i <= 5; i++) {
      const invoice = await prisma.invoice.create({
        data: {
          invoiceNumber: `INV-00000${i}`,
          warehouseId: testWarehouseId,
          customerId: testCustomerId,
          status: 'draft',
          issueDate: new Date(),
          dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
          subtotal: 1000 * i,
          taxAmount: 100 * i,
          totalAmount: 1100 * i,
          currency: 'USD'
        }
      });
      draftInvoices.push(invoice);
    }

    // Simulate concurrent month-end closing processes
    const closingPromises = draftInvoices.map(invoice => 
      prisma.$transaction(async (tx) => {
        // Check if invoice is still draft
        const current = await tx.invoice.findUnique({
          where: { id: invoice.id }
        });
        
        if (current?.status === 'draft') {
          // Simulate complex closing calculation
          await new Promise(resolve => setTimeout(resolve, 10));
          
          // Update to issued
          await tx.invoice.update({
            where: { id: invoice.id },
            data: {
              status: 'issued',
              issueDate: new Date()
            }
          });
          
          // Create related financial entries (simplified)
          await tx.storageLedger.create({
            data: {
              warehouseId: testWarehouseId,
              skuId: 'dummy-sku',
              month: new Date().getMonth() + 1,
              year: new Date().getFullYear(),
              averagePallets: 10,
              storageRate: 50,
              totalCost: invoice.totalAmount,
              status: 'pending'
            }
          });
        }
      })
    );

    await Promise.all(closingPromises);
    
    // Check that all invoices were properly closed
    const issuedInvoices = await prisma.invoice.findMany({
      where: { status: 'issued' }
    });
    
    const ledgerEntries = await prisma.storageLedger.findMany({});
    
    // Should have 5 issued invoices and 5 ledger entries
    // But race conditions might cause some to be skipped
    expect(issuedInvoices.length).toBe(5);
    expect(ledgerEntries.length).toBe(5);
  });

  test('SHOULD FAIL: Concurrent payment processing creates inconsistent balances', async () => {
    // Create an invoice with pending payment
    const invoice = await prisma.invoice.create({
      data: {
        invoiceNumber: 'INV-PAYMENT-001',
        warehouseId: testWarehouseId,
        customerId: testCustomerId,
        status: 'issued',
        issueDate: new Date(),
        dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        subtotal: 10000,
        taxAmount: 1000,
        totalAmount: 11000,
        paidAmount: 0,
        currency: 'USD'
      }
    });

    // Simulate multiple partial payments being processed concurrently
    const paymentPromises = [];
    
    // 5 payments of $2500 each (total $12,500 on $11,000 invoice)
    for (let i = 0; i < 5; i++) {
      paymentPromises.push(
        (async () => {
          const currentInvoice = await prisma.invoice.findUnique({
            where: { id: invoice.id }
          });
          
          if (currentInvoice) {
            const remainingAmount = currentInvoice.totalAmount - currentInvoice.paidAmount;
            const paymentAmount = Math.min(2500, remainingAmount);
            
            if (paymentAmount > 0) {
              await prisma.invoice.update({
                where: { id: invoice.id },
                data: {
                  paidAmount: currentInvoice.paidAmount + paymentAmount,
                  status: currentInvoice.paidAmount + paymentAmount >= currentInvoice.totalAmount 
                    ? 'paid' 
                    : 'issued'
                }
              });
              
              return paymentAmount;
            }
          }
          return 0;
        })()
      );
    }

    const payments = await Promise.all(paymentPromises);
    const totalPaid = payments.reduce((sum, payment) => sum + payment, 0);
    
    const finalInvoice = await prisma.invoice.findUnique({
      where: { id: invoice.id }
    });
    
    // Should not exceed invoice amount, but race conditions allow overpayment
    expect(finalInvoice?.paidAmount).toBeLessThanOrEqual(11000);
    expect(totalPaid).toBeLessThanOrEqual(11000);
  });
});