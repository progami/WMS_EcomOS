import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

describe('Invoice Generation Race Conditions', () => {
  let testWarehouseId: string;
  let testCustomerId: string;

  beforeEach(async () => {
    const warehouse = await prisma.warehouse.create({
      data: {
        name: 'Test Warehouse Invoice',
        code: 'TWI',
        address: 'Test Address',
        isActive: true
      }
    });
    testWarehouseId = warehouse.id;

    const user = await prisma.user.create({
      data: {
        email: 'test-invoice@example.com',
        fullName: 'Test Customer',
        passwordHash: 'hashed',
        role: 'staff'
      }
    });
    testCustomerId = user.id;
  });

  afterEach(async () => {
    await prisma.invoice.deleteMany({});
    await prisma.user.deleteMany({});
    await prisma.warehouse.deleteMany({});
  });

  test('SHOULD FAIL: Concurrent invoice number generation creates duplicates', async () => {
    // Invoice numbers are generated sequentially but without proper locking
    
    const invoicePromises = [];
    
    // Create 10 invoices concurrently
    for (let i = 0; i < 10; i++) {
      invoicePromises.push(
        (async () => {
          // Simulate the typical invoice number generation pattern
          const lastInvoice = await prisma.invoice.findFirst({
            orderBy: { invoiceNumber: 'desc' }
          });
          
          const nextNumber = lastInvoice 
            ? parseInt(lastInvoice.invoiceNumber.replace('INV-', '')) + 1
            : 1;
          
          const invoiceNumber = `INV-${String(nextNumber).padStart(6, '0')}`;
          
          // Small delay to increase race condition likelihood
          await new Promise(resolve => setTimeout(resolve, 5));
          
          return prisma.invoice.create({
            data: {
              invoiceNumber,
              warehouseId: testWarehouseId,
              customerId: testCustomerId,
              billingPeriodStart: new Date(),
              billingPeriodEnd: new Date(),
              invoiceDate: new Date(),
              issueDate: new Date(),
              dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
              subtotal: 1000,
              taxAmount: 100,
              totalAmount: 1100,
              currency: 'USD',
              status: 'pending',
              createdById: testCustomerId
            }
          });
        })()
      );
    }

    const results = await Promise.allSettled(invoicePromises);
    
    // Check for duplicate invoice numbers
    const invoices = await prisma.invoice.findMany({
      select: { invoiceNumber: true }
    });
    
    const invoiceNumbers = invoices.map(inv => inv.invoiceNumber);
    const uniqueNumbers = new Set(invoiceNumbers);
    
    // This should fail as race conditions create duplicates
    expect(uniqueNumbers.size).toBe(invoiceNumbers.length);
  });

  test('SHOULD FAIL: Concurrent monthly invoice closing causes data loss', async () => {
    // Create multiple draft invoices
    const draftInvoices = [];
    for (let i = 1; i <= 5; i++) {
      const invoice = await prisma.invoice.create({
        data: {
          invoiceNumber: `INV-00000${i}`,
          warehouseId: testWarehouseId,
          customerId: testCustomerId,
          billingPeriodStart: new Date(),
          billingPeriodEnd: new Date(),
          invoiceDate: new Date(),
          issueDate: new Date(),
          dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
          subtotal: 1000 * i,
          taxAmount: 100 * i,
          totalAmount: 1100 * i,
          currency: 'USD',
          status: 'pending',
          createdById: testCustomerId
        }
      });
      draftInvoices.push(invoice);
    }

    // Simulate concurrent month-end closing processes
    const closingPromises = draftInvoices.map(invoice => 
      prisma.$transaction(async (tx) => {
        // Check if invoice is still draft
        const current = await tx.invoice.findUnique({
          where: { id: invoice.id }
        });
        
        if (current?.status === 'pending') {
          // Simulate complex closing calculation
          await new Promise(resolve => setTimeout(resolve, 10));
          
          // Update to reconciled
          await tx.invoice.update({
            where: { id: invoice.id },
            data: {
              status: 'reconciled',
              issueDate: new Date()
            }
          });
          
          // Create related financial entries (simplified)
          const sku = await tx.sku.findFirst();
          if (sku) {
            await tx.storageLedger.create({
              data: {
                slId: `SL-${invoice.id}-${Date.now()}`,
                weekEndingDate: new Date(),
                warehouseId: testWarehouseId,
                skuId: sku.id,
                batchLot: 'BATCH-001',
                cartonsEndOfMonday: 100,
                storagePalletsCharged: 10,
                applicableWeeklyRate: 50,
                calculatedWeeklyCost: invoice.totalAmount,
                billingPeriodStart: new Date(),
                billingPeriodEnd: new Date()
              }
            });
          }
        }
      })
    );

    await Promise.all(closingPromises);
    
    // Check that all invoices were properly closed
    const reconciledInvoices = await prisma.invoice.findMany({
      where: { status: 'reconciled' }
    });
    
    const ledgerEntries = await prisma.storageLedger.findMany({});
    
    // Should have 5 reconciled invoices and 5 ledger entries
    // But race conditions might cause some to be skipped
    expect(reconciledInvoices.length).toBe(5);
    expect(ledgerEntries.length).toBe(5);
  });

  test('SHOULD FAIL: Concurrent payment processing creates inconsistent balances', async () => {
    // Create an invoice with pending payment
    const invoice = await prisma.invoice.create({
      data: {
        invoiceNumber: 'INV-PAYMENT-001',
        warehouseId: testWarehouseId,
        customerId: testCustomerId,
        billingPeriodStart: new Date(),
        billingPeriodEnd: new Date(),
        invoiceDate: new Date(),
        status: 'pending',
        issueDate: new Date(),
        dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        subtotal: 10000,
        taxAmount: 1000,
        totalAmount: 11000,
        paidAmount: 0,
        currency: 'USD',
        createdById: testCustomerId
      }
    });

    // Simulate multiple partial payments being processed concurrently
    const paymentPromises = [];
    
    // 5 payments of $2500 each (total $12,500 on $11,000 invoice)
    for (let i = 0; i < 5; i++) {
      paymentPromises.push(
        (async () => {
          const currentInvoice = await prisma.invoice.findUnique({
            where: { id: invoice.id }
          });
          
          if (currentInvoice) {
            const totalAmount = Number(currentInvoice.totalAmount);
            const paidAmount = Number(currentInvoice.paidAmount);
            const remainingAmount = totalAmount - paidAmount;
            const paymentAmount = Math.min(2500, remainingAmount);
            
            if (paymentAmount > 0) {
              await prisma.invoice.update({
                where: { id: invoice.id },
                data: {
                  paidAmount: paidAmount + paymentAmount,
                  status: paidAmount + paymentAmount >= totalAmount 
                    ? 'paid' 
                    : 'pending'
                }
              });
              
              return paymentAmount;
            }
          }
          return 0;
        })()
      );
    }

    const payments = await Promise.all(paymentPromises);
    const totalPaid = payments.reduce((sum, payment) => sum + payment, 0);
    
    const finalInvoice = await prisma.invoice.findUnique({
      where: { id: invoice.id }
    });
    
    // Should not exceed invoice amount, but race conditions allow overpayment
    expect(finalInvoice?.paidAmount).toBeLessThanOrEqual(11000);
    expect(totalPaid).toBeLessThanOrEqual(11000);
  });
});