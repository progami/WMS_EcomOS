import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

describe('Billing Period Edge Cases', () => {
  let testWarehouseId: string;
  let testCustomerId: string;

  beforeEach(async () => {
    // Create test warehouse
    const warehouse = await prisma.warehouse.create({
      data: {
        name: 'Billing Test Warehouse',
        code: 'BTW',
        address: 'Test Address',
        isActive: true
      }
    });
    testWarehouseId = warehouse.id;

    // Create test customer (using user model)
    const customer = await prisma.user.create({
      data: {
        fullName: 'Test Customer',
        email: 'test@customer.com',
        passwordHash: 'hashedpassword',
        role: 'staff',
        isActive: true
      }
    });
    testCustomerId = customer.id;
  });

  afterEach(async () => {
    await prisma.invoice.deleteMany({});
    await prisma.user.deleteMany({});
    await prisma.warehouse.deleteMany({});
  });
  test('SHOULD FAIL: Daylight Saving Time billing period confusion', async () => {
    // Test billing during DST transition
    // Spring forward: March 10, 2024, 2:00 AM -> 3:00 AM
    const dstTransitionDate = new Date('2024-03-10T07:00:00Z'); // 2 AM CST in UTC
    
    const calculateBillingHours = (start: Date, end: Date) => {
      // BUG: Simple date subtraction doesn't account for DST
      const diffMs = end.getTime() - start.getTime();
      return diffMs / (1000 * 60 * 60);
    };
    
    // 24-hour billing period across DST change
    const billingStart = new Date('2024-03-10T00:00:00-06:00');
    const billingEnd = new Date('2024-03-11T00:00:00-05:00'); // Note timezone change
    
    const billedHours = calculateBillingHours(billingStart, billingEnd);
    
    // The vulnerable implementation shows 24 hours instead of 23
    expect(billedHours).toBe(24);
  });

  test('SHOULD FAIL: Leap year billing calculations', async () => {
    // February 2024 is a leap year
    const calculateMonthlyRate = (yearlyRate: number, month: number, year: number) => {
      // BUG: Assumes all months have same number of days
      return yearlyRate / 12;
    };
    
    const yearlyRate = 36500; // $100/day for a year
    
    const febRate2024 = calculateMonthlyRate(yearlyRate, 2, 2024); // Leap year
    const febRate2023 = calculateMonthlyRate(yearlyRate, 2, 2023); // Non-leap year
    
    // The vulnerable implementation returns the same rate for both
    expect(febRate2024).toBe(febRate2023);
  });

  test('SHOULD FAIL: Month-end billing with variable days', async () => {
    const calculateProRatedAmount = (monthlyRate: number, startDay: number, month: number, year: number) => {
      // BUG: Assumes all months have 30 days
      const daysInMonth = 30;
      const billingDays = daysInMonth - startDay + 1;
      return (monthlyRate / daysInMonth) * billingDays;
    };
    
    const monthlyRate = 3000;
    
    // Customer starts on Jan 15 (31-day month)
    const janAmount = calculateProRatedAmount(monthlyRate, 15, 1, 2024);
    
    // Customer starts on Feb 15 (29-day month in 2024)
    const febAmount = calculateProRatedAmount(monthlyRate, 15, 2, 2024);
    
    // The vulnerable implementation uses 30 days for all months
    const dailyRate = monthlyRate / 30;
    const expectedJan = dailyRate * 17; // 17 days (from Jan 15 to 31)
    const expectedFeb = dailyRate * 16; // 16 days (from Feb 15 to 30 in the buggy calc)
    
    expect(janAmount).toBeCloseTo(expectedJan, 2);
    expect(febAmount).toBeCloseTo(expectedFeb, 2);
  });

  test('SHOULD FAIL: Billing across year boundary', async () => {
    const calculateBillingPeriod = (startDate: Date, endDate: Date) => {
      // BUG: Doesn't handle year transitions properly
      const startMonth = startDate.getMonth() + 1;
      const endMonth = endDate.getMonth() + 1;
      const monthsDiff = endMonth - startMonth;
      
      return {
        months: monthsDiff < 0 ? monthsDiff + 12 : monthsDiff,
        crossesYearBoundary: false // BUG: Always false!
      };
    };
    
    const start = new Date('2023-12-15');
    const end = new Date('2024-01-15');
    
    const billing = calculateBillingPeriod(start, end);
    
    // The vulnerable implementation doesn't detect year boundary crossing
    expect(billing.crossesYearBoundary).toBe(false);
    expect(billing.months).toBe(1);
  });

  test('SHOULD FAIL: Concurrent billing run creates duplicates', async () => {
    // Simulate end-of-month billing process
    const runMonthlyBilling = async (month: number, year: number) => {
      // BUG: No lock to prevent concurrent runs
      const existing = await prisma.invoice.findFirst({
        where: {
          billingMonth: month,
          billingYear: year,
          type: 'monthly'
        }
      });
      
      // Race condition: Multiple processes might pass this check
      if (!existing) {
        await new Promise(resolve => setTimeout(resolve, 100)); // Simulate processing
        
        return prisma.invoice.create({
          data: {
            invoiceNumber: `INV-${year}-${month}-001`,
            warehouseId: testWarehouseId,
            customerId: testCustomerId,
            billingMonth: month,
            billingYear: year,
            type: 'monthly',
            status: 'pending',
            issueDate: new Date(),
            dueDate: new Date(),
            subtotal: 1000,
            taxAmount: 100,
            totalAmount: 1100,
            currency: 'USD'
          }
        });
      }
    };
    
    // Run billing twice concurrently
    const [result1, result2] = await Promise.all([
      runMonthlyBilling(1, 2024),
      runMonthlyBilling(1, 2024)
    ]);
    
    // Check for duplicates
    const invoices = await prisma.invoice.findMany({
      where: {
        billingMonth: 1,
        billingYear: 2024,
        type: 'monthly'
      }
    });
    
    // Race condition creates 2 invoices instead of 1
    expect(invoices.length).toBe(2);
  });

  test('SHOULD FAIL: Fractional day calculations', async () => {
    const calculateStorageCostPerDay = (pallets: number, ratePerPalletPerMonth: number) => {
      // BUG: Inconsistent fractional day handling
      const daysInMonth = 30; // Hardcoded!
      const dailyRate = ratePerPalletPerMonth / daysInMonth;
      return pallets * dailyRate;
    };
    
    // Storage for 0.5 days (12 hours)
    const halfDayCost = calculateStorageCostPerDay(10, 300) * 0.5;
    
    // Storage from 11 PM to 1 AM (2 hours across day boundary)
    const calculateHourlyStorage = (hours: number, pallets: number, monthlyRate: number) => {
      // Different calculation method!
      const hourlyRate = monthlyRate / (30 * 24); // Assumes 30-day month
      return hours * pallets * hourlyRate;
    };
    
    const crossDayCost = calculateHourlyStorage(2, 10, 300);
    
    // These should use consistent calculation methods
    const twelveHourCost = calculateHourlyStorage(12, 10, 300);
    expect(halfDayCost).toBeCloseTo(twelveHourCost, 2);
  });

  test('SHOULD FAIL: Retroactive rate changes', async () => {
    // Rate change in middle of month
    const oldRate = 50;
    const newRate = 60;
    const changeDate = new Date('2024-01-15');
    
    const calculateMonthlyCharge = (month: number, year: number) => {
      // BUG: Doesn't properly handle mid-month rate changes
      const currentRate = newRate; // Just uses current rate!
      const daysInMonth = 31;
      return currentRate * daysInMonth;
    };
    
    const januaryCharge = calculateMonthlyCharge(1, 2024);
    
    // The vulnerable implementation just uses the new rate for the whole month
    const vulnerableCharge = newRate * 31;
    
    expect(januaryCharge).toBe(vulnerableCharge);
  });
});