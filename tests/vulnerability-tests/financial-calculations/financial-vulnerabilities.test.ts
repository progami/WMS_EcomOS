import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';
import { PrismaClient } from '@prisma/client';
// import { calculateStorageCost } from '@/lib/cost-calculations';

const prisma = new PrismaClient();

describe('Financial Calculation Vulnerabilities', () => {
  let testWarehouseId: string;
  let testSkuId: string;
  let testUserId: string;
  let testCostRateId: string;

  beforeEach(async () => {
    const warehouse = await prisma.warehouse.create({
      data: {
        name: 'Financial Test Warehouse',
        code: 'FTW',
        address: 'Test Address',
        isActive: true
      }
    });
    testWarehouseId = warehouse.id;

    const sku = await prisma.sku.create({
      data: {
        skuCode: 'FIN-SKU',
        description: 'Financial Test SKU',
        packSize: 1,
        unitsPerCarton: 10,
        isActive: true
      }
    });
    testSkuId = sku.id;

    const user = await prisma.user.create({
      data: {
        email: 'financial@test.com',
        fullName: 'Financial Test User',
        passwordHash: 'hashed',
        role: 'admin'
      }
    });
    testUserId = user.id;

    const costRate = await prisma.costRate.create({
      data: {
        warehouseId: testWarehouseId,
        costCategory: 'Storage',
        costName: 'Default Storage Rate',
        costValue: 10.00,
        unitOfMeasure: 'per_pallet',
        effectiveDate: new Date(),
        isActive: true,
        createdById: testUserId
      }
    });
    testCostRateId = costRate.id;
  });

  afterEach(async () => {
    // Clean up test data
    await prisma.calculatedCost.deleteMany({});
    await prisma.storageLedger.deleteMany({});
    await prisma.costRate.deleteMany({});
    await prisma.user.deleteMany({});
    await prisma.sku.deleteMany({});
    await prisma.warehouse.deleteMany({});
  });

  test('SHOULD FAIL: Division by zero in storage calculations', async () => {
    // Create cost rate with zero pallet configuration
    const costRate = await prisma.costRate.create({
      data: {
        warehouseId: testWarehouseId,
        costCategory: 'STORAGE',
        costName: 'Pallet Storage',
        costValue: 50.00,
        unitOfMeasure: 'per_pallet',
        effectiveDate: new Date(),
        isActive: true,
        createdById: testUserId
      }
    });

    // Calculate storage cost
    const calculateCostPerUnit = (totalCost: number, palletConfig: number, unitsPerPallet: number) => {
      // BUG: No check for zero values
      const totalUnits = palletConfig * unitsPerPallet;
      return totalCost / totalUnits; // Division by zero!
    };

    // This demonstrates the vulnerability - division by zero returns Infinity
    const palletConfig = 0; // Zero pallets!
    const result = calculateCostPerUnit(1000, palletConfig, 100);
    expect(result).toBe(Infinity);
  });

  test('SHOULD FAIL: Floating point precision errors in money calculations', async () => {
    // Test case: Splitting $10.00 among 3 units
    const totalAmount = 10.00;
    const unitCount = 3;
    
    const calculateUnitPrice = (total: number, units: number) => {
      // BUG: Using regular division for money
      return total / units; // Results in 3.3333333...
    };
    
    const unitPrice = calculateUnitPrice(totalAmount, unitCount);
    const calculatedTotal = unitPrice * unitCount;
    
    // This should fail - floating point error accumulation
    expect(calculatedTotal).toBe(totalAmount);
    
    // Test currency calculations
    const prices = [19.99, 29.99, 39.99];
    const sum = prices.reduce((a, b) => a + b, 0);
    
    // Should be exactly 89.97, but floating point might differ
    expect(sum).toBe(89.97);
  });

  test('SHOULD FAIL: Timezone issues in billing period calculations', async () => {
    // Create storage ledger entries at month boundary
    const entries = [];
    
    // Entry created at 11:30 PM on last day of month (local time)
    const lastDayLocal = new Date(2024, 0, 31, 23, 30, 0); // Jan 31, 11:30 PM
    
    entries.push(await prisma.storageLedger.create({
      data: {
        slId: `SL-${Date.now()}-1`,
        warehouseId: testWarehouseId,
        skuId: testSkuId,
        batchLot: 'TEST-001',
        weekEndingDate: lastDayLocal,
        cartonsEndOfMonday: 100,
        storagePalletsCharged: 10,
        applicableWeeklyRate: 50,
        calculatedWeeklyCost: 500,
        billingPeriodStart: new Date(2024, 0, 1),
        billingPeriodEnd: new Date(2024, 0, 31)
      }
    }));

    // Function to determine billing month
    const getBillingMonth = (date: Date) => {
      // BUG: Uses local date without considering timezone
      return {
        month: date.getMonth() + 1,
        year: date.getFullYear()
      };
    };

    // In UTC, this might be February 1st already!
    const billing = getBillingMonth(lastDayLocal);
    
    // Get entries for January
    const januaryEntries = await prisma.storageLedger.findMany({
      where: {
        billingPeriodStart: {
          gte: new Date(2024, 0, 1)
        },
        billingPeriodEnd: {
          lte: new Date(2024, 0, 31)
        }
      }
    });

    // This might fail if timezone conversion puts entry in February
    expect(januaryEntries.length).toBe(1);
  });

  test('SHOULD FAIL: Negative value handling in cost calculations', async () => {
    // Test negative quantities
    const calculateTotalCost = (quantity: number, rate: number) => {
      // BUG: No validation for negative values
      return quantity * rate;
    };

    const negativeCost = calculateTotalCost(-10, 50);
    
    // This should fail - costs should never be negative
    expect(negativeCost).toBeGreaterThanOrEqual(0);

    // Test refund calculations
    const processRefund = (originalAmount: number, refundPercentage: number) => {
      // BUG: No bounds checking
      const refundAmount = originalAmount * (refundPercentage / 100);
      return originalAmount - refundAmount;
    };

    // 150% refund - customer gets more than they paid!
    const afterRefund = processRefund(100, 150);
    
    // This should fail - can't refund more than original amount
    expect(afterRefund).toBeGreaterThanOrEqual(0);
  });

  test('SHOULD FAIL: Currency conversion rounding errors', async () => {
    // Test currency conversion with multiple operations
    const convertCurrency = (amount: number, rate: number) => {
      // BUG: No proper rounding for currency
      return amount * rate;
    };

    // Convert $100 USD to EUR and back (rate: 0.85 EUR = 1 USD)
    const usdAmount = 100.00;
    const usdToEurRate = 0.85;
    const eurToUsdRate = 1.17647; // 1/0.85
    
    const eurAmount = convertCurrency(usdAmount, usdToEurRate);
    const backToUsd = convertCurrency(eurAmount, eurToUsdRate);
    
    // This should fail - conversion loses precision
    expect(backToUsd).toBe(usdAmount);
  });

  test('SHOULD FAIL: Overflow in large financial calculations', async () => {
    // Test with very large numbers
    const calculateYearlyRevenue = (dailyRevenue: number, days: number) => {
      // BUG: No overflow protection
      return dailyRevenue * days;
    };

    // Large daily revenue
    const dailyRevenue = 1e15; // $1 quadrillion
    const yearlyRevenue = calculateYearlyRevenue(dailyRevenue, 365);
    
    // Check if calculation is accurate
    expect(yearlyRevenue).toBe(dailyRevenue * 365);
    
    // This might fail due to JavaScript number limitations
    expect(yearlyRevenue).toBeLessThan(Number.MAX_SAFE_INTEGER);
  });

  test('SHOULD FAIL: Race conditions in financial transaction processing', async () => {
    // Create initial balance
    let accountBalance = 1000.00;
    
    // Simulate concurrent financial transactions
    const processTransaction = async (amount: number) => {
      // BUG: Read-modify-write without locking
      const currentBalance = accountBalance;
      
      // Simulate processing delay
      await new Promise(resolve => setTimeout(resolve, 10));
      
      accountBalance = currentBalance + amount;
      return accountBalance;
    };

    // Process multiple transactions concurrently
    const transactions = [
      processTransaction(100),
      processTransaction(200),
      processTransaction(-150),
      processTransaction(50)
    ];

    await Promise.all(transactions);
    
    // Expected: 1000 + 100 + 200 - 150 + 50 = 1200
    // But race conditions might cause different result
    expect(accountBalance).toBe(1200);
  });

  test('SHOULD FAIL: Inconsistent tax calculation methods', async () => {
    // Different tax calculation methods that should give same result
    const calculateTaxInclusive = (totalWithTax: number, taxRate: number) => {
      // Method 1: Extract tax from inclusive amount
      return totalWithTax - (totalWithTax / (1 + taxRate));
    };

    const calculateTaxExclusive = (subtotal: number, taxRate: number) => {
      // Method 2: Add tax to exclusive amount
      return subtotal * taxRate;
    };

    // Test with 10% tax
    const taxRate = 0.10;
    const totalInclusive = 110.00; // $100 + 10% tax
    const subtotal = 100.00;
    
    const tax1 = calculateTaxInclusive(totalInclusive, taxRate);
    const tax2 = calculateTaxExclusive(subtotal, taxRate);
    
    // This might fail due to rounding differences
    expect(tax1).toBe(tax2);
  });

  test('SHOULD FAIL: Missing audit trail for financial calculations', async () => {
    // Simulate cost calculation without audit logging
    const calculateAndStoreCost = async (data: any) => {
      const cost = data.quantity * data.rate;
      
      // BUG: No audit trail or calculation history
      await prisma.calculatedCost.create({
        data: {
          calculatedCostId: `CC-${Date.now()}`,
          transactionType: 'storage',
          transactionReferenceId: `REF-${Date.now()}`,
          costRateId: testCostRateId,
          warehouseId: data.warehouseId,
          skuId: data.skuId,
          transactionDate: new Date(),
          billingWeekEnding: new Date(),
          billingPeriodStart: new Date(),
          billingPeriodEnd: new Date(),
          quantityCharged: data.quantity,
          applicableRate: data.rate,
          calculatedCost: cost,
          finalExpectedCost: cost,
          createdById: testUserId
          // Missing: audit trail of calculation inputs, formula used
        }
      });
      
      return cost;
    };

    const result = await calculateAndStoreCost({
      warehouseId: testWarehouseId,
      skuId: testSkuId,
      quantity: 100,
      rate: 50
    });

    // Try to retrieve calculation details
    const storedCost = await prisma.calculatedCost.findFirst({
      where: {
        warehouseId: testWarehouseId,
        skuId: testSkuId
      }
    });

    // This should fail - we can't verify how the cost was calculated
    expect(storedCost).toHaveProperty('calculationInputs');
    expect(storedCost).toHaveProperty('formulaUsed');
  });
});